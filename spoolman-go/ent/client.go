// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"spoolman-go/ent/migrate"

	"spoolman-go/ent/filament"
	"spoolman-go/ent/filamentfield"
	"spoolman-go/ent/setting"
	"spoolman-go/ent/spool"
	"spoolman-go/ent/spoolfield"
	"spoolman-go/ent/spoolvendor"
	"spoolman-go/ent/vendorfield"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Filament is the client for interacting with the Filament builders.
	Filament *FilamentClient
	// FilamentField is the client for interacting with the FilamentField builders.
	FilamentField *FilamentFieldClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// Spool is the client for interacting with the Spool builders.
	Spool *SpoolClient
	// SpoolField is the client for interacting with the SpoolField builders.
	SpoolField *SpoolFieldClient
	// SpoolVendor is the client for interacting with the SpoolVendor builders.
	SpoolVendor *SpoolVendorClient
	// VendorField is the client for interacting with the VendorField builders.
	VendorField *VendorFieldClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Filament = NewFilamentClient(c.config)
	c.FilamentField = NewFilamentFieldClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.Spool = NewSpoolClient(c.config)
	c.SpoolField = NewSpoolFieldClient(c.config)
	c.SpoolVendor = NewSpoolVendorClient(c.config)
	c.VendorField = NewVendorFieldClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Filament:      NewFilamentClient(cfg),
		FilamentField: NewFilamentFieldClient(cfg),
		Setting:       NewSettingClient(cfg),
		Spool:         NewSpoolClient(cfg),
		SpoolField:    NewSpoolFieldClient(cfg),
		SpoolVendor:   NewSpoolVendorClient(cfg),
		VendorField:   NewVendorFieldClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Filament:      NewFilamentClient(cfg),
		FilamentField: NewFilamentFieldClient(cfg),
		Setting:       NewSettingClient(cfg),
		Spool:         NewSpoolClient(cfg),
		SpoolField:    NewSpoolFieldClient(cfg),
		SpoolVendor:   NewSpoolVendorClient(cfg),
		VendorField:   NewVendorFieldClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Filament.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Filament, c.FilamentField, c.Setting, c.Spool, c.SpoolField, c.SpoolVendor,
		c.VendorField,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Filament, c.FilamentField, c.Setting, c.Spool, c.SpoolField, c.SpoolVendor,
		c.VendorField,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *FilamentMutation:
		return c.Filament.mutate(ctx, m)
	case *FilamentFieldMutation:
		return c.FilamentField.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *SpoolMutation:
		return c.Spool.mutate(ctx, m)
	case *SpoolFieldMutation:
		return c.SpoolField.mutate(ctx, m)
	case *SpoolVendorMutation:
		return c.SpoolVendor.mutate(ctx, m)
	case *VendorFieldMutation:
		return c.VendorField.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// FilamentClient is a client for the Filament schema.
type FilamentClient struct {
	config
}

// NewFilamentClient returns a client for the Filament from the given config.
func NewFilamentClient(c config) *FilamentClient {
	return &FilamentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filament.Hooks(f(g(h())))`.
func (c *FilamentClient) Use(hooks ...Hook) {
	c.hooks.Filament = append(c.hooks.Filament, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filament.Intercept(f(g(h())))`.
func (c *FilamentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Filament = append(c.inters.Filament, interceptors...)
}

// Create returns a builder for creating a Filament entity.
func (c *FilamentClient) Create() *FilamentCreate {
	mutation := newFilamentMutation(c.config, OpCreate)
	return &FilamentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Filament entities.
func (c *FilamentClient) CreateBulk(builders ...*FilamentCreate) *FilamentCreateBulk {
	return &FilamentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FilamentClient) MapCreateBulk(slice any, setFunc func(*FilamentCreate, int)) *FilamentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FilamentCreateBulk{err: fmt.Errorf("calling to FilamentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FilamentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FilamentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Filament.
func (c *FilamentClient) Update() *FilamentUpdate {
	mutation := newFilamentMutation(c.config, OpUpdate)
	return &FilamentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FilamentClient) UpdateOne(f *Filament) *FilamentUpdateOne {
	mutation := newFilamentMutation(c.config, OpUpdateOne, withFilament(f))
	return &FilamentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FilamentClient) UpdateOneID(id int) *FilamentUpdateOne {
	mutation := newFilamentMutation(c.config, OpUpdateOne, withFilamentID(id))
	return &FilamentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Filament.
func (c *FilamentClient) Delete() *FilamentDelete {
	mutation := newFilamentMutation(c.config, OpDelete)
	return &FilamentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FilamentClient) DeleteOne(f *Filament) *FilamentDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FilamentClient) DeleteOneID(id int) *FilamentDeleteOne {
	builder := c.Delete().Where(filament.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FilamentDeleteOne{builder}
}

// Query returns a query builder for Filament.
func (c *FilamentClient) Query() *FilamentQuery {
	return &FilamentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFilament},
		inters: c.Interceptors(),
	}
}

// Get returns a Filament entity by its id.
func (c *FilamentClient) Get(ctx context.Context, id int) (*Filament, error) {
	return c.Query().Where(filament.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FilamentClient) GetX(ctx context.Context, id int) *Filament {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVendor queries the vendor edge of a Filament.
func (c *FilamentClient) QueryVendor(f *Filament) *SpoolVendorQuery {
	query := (&SpoolVendorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filament.Table, filament.FieldID, id),
			sqlgraph.To(spoolvendor.Table, spoolvendor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filament.VendorTable, filament.VendorColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySpools queries the spools edge of a Filament.
func (c *FilamentClient) QuerySpools(f *Filament) *SpoolQuery {
	query := (&SpoolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filament.Table, filament.FieldID, id),
			sqlgraph.To(spool.Table, spool.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, filament.SpoolsTable, filament.SpoolsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtra queries the extra edge of a Filament.
func (c *FilamentClient) QueryExtra(f *Filament) *FilamentFieldQuery {
	query := (&FilamentFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filament.Table, filament.FieldID, id),
			sqlgraph.To(filamentfield.Table, filamentfield.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, filament.ExtraTable, filament.ExtraColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FilamentClient) Hooks() []Hook {
	return c.hooks.Filament
}

// Interceptors returns the client interceptors.
func (c *FilamentClient) Interceptors() []Interceptor {
	return c.inters.Filament
}

func (c *FilamentClient) mutate(ctx context.Context, m *FilamentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FilamentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FilamentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FilamentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FilamentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Filament mutation op: %q", m.Op())
	}
}

// FilamentFieldClient is a client for the FilamentField schema.
type FilamentFieldClient struct {
	config
}

// NewFilamentFieldClient returns a client for the FilamentField from the given config.
func NewFilamentFieldClient(c config) *FilamentFieldClient {
	return &FilamentFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filamentfield.Hooks(f(g(h())))`.
func (c *FilamentFieldClient) Use(hooks ...Hook) {
	c.hooks.FilamentField = append(c.hooks.FilamentField, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filamentfield.Intercept(f(g(h())))`.
func (c *FilamentFieldClient) Intercept(interceptors ...Interceptor) {
	c.inters.FilamentField = append(c.inters.FilamentField, interceptors...)
}

// Create returns a builder for creating a FilamentField entity.
func (c *FilamentFieldClient) Create() *FilamentFieldCreate {
	mutation := newFilamentFieldMutation(c.config, OpCreate)
	return &FilamentFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FilamentField entities.
func (c *FilamentFieldClient) CreateBulk(builders ...*FilamentFieldCreate) *FilamentFieldCreateBulk {
	return &FilamentFieldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FilamentFieldClient) MapCreateBulk(slice any, setFunc func(*FilamentFieldCreate, int)) *FilamentFieldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FilamentFieldCreateBulk{err: fmt.Errorf("calling to FilamentFieldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FilamentFieldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FilamentFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FilamentField.
func (c *FilamentFieldClient) Update() *FilamentFieldUpdate {
	mutation := newFilamentFieldMutation(c.config, OpUpdate)
	return &FilamentFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FilamentFieldClient) UpdateOne(ff *FilamentField) *FilamentFieldUpdateOne {
	mutation := newFilamentFieldMutation(c.config, OpUpdateOne, withFilamentField(ff))
	return &FilamentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FilamentFieldClient) UpdateOneID(id int) *FilamentFieldUpdateOne {
	mutation := newFilamentFieldMutation(c.config, OpUpdateOne, withFilamentFieldID(id))
	return &FilamentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FilamentField.
func (c *FilamentFieldClient) Delete() *FilamentFieldDelete {
	mutation := newFilamentFieldMutation(c.config, OpDelete)
	return &FilamentFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FilamentFieldClient) DeleteOne(ff *FilamentField) *FilamentFieldDeleteOne {
	return c.DeleteOneID(ff.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FilamentFieldClient) DeleteOneID(id int) *FilamentFieldDeleteOne {
	builder := c.Delete().Where(filamentfield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FilamentFieldDeleteOne{builder}
}

// Query returns a query builder for FilamentField.
func (c *FilamentFieldClient) Query() *FilamentFieldQuery {
	return &FilamentFieldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFilamentField},
		inters: c.Interceptors(),
	}
}

// Get returns a FilamentField entity by its id.
func (c *FilamentFieldClient) Get(ctx context.Context, id int) (*FilamentField, error) {
	return c.Query().Where(filamentfield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FilamentFieldClient) GetX(ctx context.Context, id int) *FilamentField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFilament queries the filament edge of a FilamentField.
func (c *FilamentFieldClient) QueryFilament(ff *FilamentField) *FilamentQuery {
	query := (&FilamentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ff.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filamentfield.Table, filamentfield.FieldID, id),
			sqlgraph.To(filament.Table, filament.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filamentfield.FilamentTable, filamentfield.FilamentColumn),
		)
		fromV = sqlgraph.Neighbors(ff.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FilamentFieldClient) Hooks() []Hook {
	return c.hooks.FilamentField
}

// Interceptors returns the client interceptors.
func (c *FilamentFieldClient) Interceptors() []Interceptor {
	return c.inters.FilamentField
}

func (c *FilamentFieldClient) mutate(ctx context.Context, m *FilamentFieldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FilamentFieldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FilamentFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FilamentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FilamentFieldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FilamentField mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(s *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(s))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id int) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(s *Setting) *SettingDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id int) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id int) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id int) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	return c.hooks.Setting
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Setting mutation op: %q", m.Op())
	}
}

// SpoolClient is a client for the Spool schema.
type SpoolClient struct {
	config
}

// NewSpoolClient returns a client for the Spool from the given config.
func NewSpoolClient(c config) *SpoolClient {
	return &SpoolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spool.Hooks(f(g(h())))`.
func (c *SpoolClient) Use(hooks ...Hook) {
	c.hooks.Spool = append(c.hooks.Spool, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `spool.Intercept(f(g(h())))`.
func (c *SpoolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Spool = append(c.inters.Spool, interceptors...)
}

// Create returns a builder for creating a Spool entity.
func (c *SpoolClient) Create() *SpoolCreate {
	mutation := newSpoolMutation(c.config, OpCreate)
	return &SpoolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Spool entities.
func (c *SpoolClient) CreateBulk(builders ...*SpoolCreate) *SpoolCreateBulk {
	return &SpoolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SpoolClient) MapCreateBulk(slice any, setFunc func(*SpoolCreate, int)) *SpoolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SpoolCreateBulk{err: fmt.Errorf("calling to SpoolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SpoolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SpoolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Spool.
func (c *SpoolClient) Update() *SpoolUpdate {
	mutation := newSpoolMutation(c.config, OpUpdate)
	return &SpoolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SpoolClient) UpdateOne(s *Spool) *SpoolUpdateOne {
	mutation := newSpoolMutation(c.config, OpUpdateOne, withSpool(s))
	return &SpoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SpoolClient) UpdateOneID(id int) *SpoolUpdateOne {
	mutation := newSpoolMutation(c.config, OpUpdateOne, withSpoolID(id))
	return &SpoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Spool.
func (c *SpoolClient) Delete() *SpoolDelete {
	mutation := newSpoolMutation(c.config, OpDelete)
	return &SpoolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SpoolClient) DeleteOne(s *Spool) *SpoolDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SpoolClient) DeleteOneID(id int) *SpoolDeleteOne {
	builder := c.Delete().Where(spool.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SpoolDeleteOne{builder}
}

// Query returns a query builder for Spool.
func (c *SpoolClient) Query() *SpoolQuery {
	return &SpoolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSpool},
		inters: c.Interceptors(),
	}
}

// Get returns a Spool entity by its id.
func (c *SpoolClient) Get(ctx context.Context, id int) (*Spool, error) {
	return c.Query().Where(spool.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SpoolClient) GetX(ctx context.Context, id int) *Spool {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFilament queries the filament edge of a Spool.
func (c *SpoolClient) QueryFilament(s *Spool) *FilamentQuery {
	query := (&FilamentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(spool.Table, spool.FieldID, id),
			sqlgraph.To(filament.Table, filament.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, spool.FilamentTable, spool.FilamentColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtra queries the extra edge of a Spool.
func (c *SpoolClient) QueryExtra(s *Spool) *SpoolFieldQuery {
	query := (&SpoolFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(spool.Table, spool.FieldID, id),
			sqlgraph.To(spoolfield.Table, spoolfield.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, spool.ExtraTable, spool.ExtraColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SpoolClient) Hooks() []Hook {
	return c.hooks.Spool
}

// Interceptors returns the client interceptors.
func (c *SpoolClient) Interceptors() []Interceptor {
	return c.inters.Spool
}

func (c *SpoolClient) mutate(ctx context.Context, m *SpoolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SpoolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SpoolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SpoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SpoolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Spool mutation op: %q", m.Op())
	}
}

// SpoolFieldClient is a client for the SpoolField schema.
type SpoolFieldClient struct {
	config
}

// NewSpoolFieldClient returns a client for the SpoolField from the given config.
func NewSpoolFieldClient(c config) *SpoolFieldClient {
	return &SpoolFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spoolfield.Hooks(f(g(h())))`.
func (c *SpoolFieldClient) Use(hooks ...Hook) {
	c.hooks.SpoolField = append(c.hooks.SpoolField, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `spoolfield.Intercept(f(g(h())))`.
func (c *SpoolFieldClient) Intercept(interceptors ...Interceptor) {
	c.inters.SpoolField = append(c.inters.SpoolField, interceptors...)
}

// Create returns a builder for creating a SpoolField entity.
func (c *SpoolFieldClient) Create() *SpoolFieldCreate {
	mutation := newSpoolFieldMutation(c.config, OpCreate)
	return &SpoolFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SpoolField entities.
func (c *SpoolFieldClient) CreateBulk(builders ...*SpoolFieldCreate) *SpoolFieldCreateBulk {
	return &SpoolFieldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SpoolFieldClient) MapCreateBulk(slice any, setFunc func(*SpoolFieldCreate, int)) *SpoolFieldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SpoolFieldCreateBulk{err: fmt.Errorf("calling to SpoolFieldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SpoolFieldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SpoolFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SpoolField.
func (c *SpoolFieldClient) Update() *SpoolFieldUpdate {
	mutation := newSpoolFieldMutation(c.config, OpUpdate)
	return &SpoolFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SpoolFieldClient) UpdateOne(sf *SpoolField) *SpoolFieldUpdateOne {
	mutation := newSpoolFieldMutation(c.config, OpUpdateOne, withSpoolField(sf))
	return &SpoolFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SpoolFieldClient) UpdateOneID(id int) *SpoolFieldUpdateOne {
	mutation := newSpoolFieldMutation(c.config, OpUpdateOne, withSpoolFieldID(id))
	return &SpoolFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SpoolField.
func (c *SpoolFieldClient) Delete() *SpoolFieldDelete {
	mutation := newSpoolFieldMutation(c.config, OpDelete)
	return &SpoolFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SpoolFieldClient) DeleteOne(sf *SpoolField) *SpoolFieldDeleteOne {
	return c.DeleteOneID(sf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SpoolFieldClient) DeleteOneID(id int) *SpoolFieldDeleteOne {
	builder := c.Delete().Where(spoolfield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SpoolFieldDeleteOne{builder}
}

// Query returns a query builder for SpoolField.
func (c *SpoolFieldClient) Query() *SpoolFieldQuery {
	return &SpoolFieldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSpoolField},
		inters: c.Interceptors(),
	}
}

// Get returns a SpoolField entity by its id.
func (c *SpoolFieldClient) Get(ctx context.Context, id int) (*SpoolField, error) {
	return c.Query().Where(spoolfield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SpoolFieldClient) GetX(ctx context.Context, id int) *SpoolField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySpool queries the spool edge of a SpoolField.
func (c *SpoolFieldClient) QuerySpool(sf *SpoolField) *SpoolQuery {
	query := (&SpoolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(spoolfield.Table, spoolfield.FieldID, id),
			sqlgraph.To(spool.Table, spool.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, spoolfield.SpoolTable, spoolfield.SpoolColumn),
		)
		fromV = sqlgraph.Neighbors(sf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SpoolFieldClient) Hooks() []Hook {
	return c.hooks.SpoolField
}

// Interceptors returns the client interceptors.
func (c *SpoolFieldClient) Interceptors() []Interceptor {
	return c.inters.SpoolField
}

func (c *SpoolFieldClient) mutate(ctx context.Context, m *SpoolFieldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SpoolFieldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SpoolFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SpoolFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SpoolFieldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SpoolField mutation op: %q", m.Op())
	}
}

// SpoolVendorClient is a client for the SpoolVendor schema.
type SpoolVendorClient struct {
	config
}

// NewSpoolVendorClient returns a client for the SpoolVendor from the given config.
func NewSpoolVendorClient(c config) *SpoolVendorClient {
	return &SpoolVendorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spoolvendor.Hooks(f(g(h())))`.
func (c *SpoolVendorClient) Use(hooks ...Hook) {
	c.hooks.SpoolVendor = append(c.hooks.SpoolVendor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `spoolvendor.Intercept(f(g(h())))`.
func (c *SpoolVendorClient) Intercept(interceptors ...Interceptor) {
	c.inters.SpoolVendor = append(c.inters.SpoolVendor, interceptors...)
}

// Create returns a builder for creating a SpoolVendor entity.
func (c *SpoolVendorClient) Create() *SpoolVendorCreate {
	mutation := newSpoolVendorMutation(c.config, OpCreate)
	return &SpoolVendorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SpoolVendor entities.
func (c *SpoolVendorClient) CreateBulk(builders ...*SpoolVendorCreate) *SpoolVendorCreateBulk {
	return &SpoolVendorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SpoolVendorClient) MapCreateBulk(slice any, setFunc func(*SpoolVendorCreate, int)) *SpoolVendorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SpoolVendorCreateBulk{err: fmt.Errorf("calling to SpoolVendorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SpoolVendorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SpoolVendorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SpoolVendor.
func (c *SpoolVendorClient) Update() *SpoolVendorUpdate {
	mutation := newSpoolVendorMutation(c.config, OpUpdate)
	return &SpoolVendorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SpoolVendorClient) UpdateOne(sv *SpoolVendor) *SpoolVendorUpdateOne {
	mutation := newSpoolVendorMutation(c.config, OpUpdateOne, withSpoolVendor(sv))
	return &SpoolVendorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SpoolVendorClient) UpdateOneID(id int) *SpoolVendorUpdateOne {
	mutation := newSpoolVendorMutation(c.config, OpUpdateOne, withSpoolVendorID(id))
	return &SpoolVendorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SpoolVendor.
func (c *SpoolVendorClient) Delete() *SpoolVendorDelete {
	mutation := newSpoolVendorMutation(c.config, OpDelete)
	return &SpoolVendorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SpoolVendorClient) DeleteOne(sv *SpoolVendor) *SpoolVendorDeleteOne {
	return c.DeleteOneID(sv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SpoolVendorClient) DeleteOneID(id int) *SpoolVendorDeleteOne {
	builder := c.Delete().Where(spoolvendor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SpoolVendorDeleteOne{builder}
}

// Query returns a query builder for SpoolVendor.
func (c *SpoolVendorClient) Query() *SpoolVendorQuery {
	return &SpoolVendorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSpoolVendor},
		inters: c.Interceptors(),
	}
}

// Get returns a SpoolVendor entity by its id.
func (c *SpoolVendorClient) Get(ctx context.Context, id int) (*SpoolVendor, error) {
	return c.Query().Where(spoolvendor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SpoolVendorClient) GetX(ctx context.Context, id int) *SpoolVendor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFilaments queries the filaments edge of a SpoolVendor.
func (c *SpoolVendorClient) QueryFilaments(sv *SpoolVendor) *FilamentQuery {
	query := (&FilamentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(spoolvendor.Table, spoolvendor.FieldID, id),
			sqlgraph.To(filament.Table, filament.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, spoolvendor.FilamentsTable, spoolvendor.FilamentsColumn),
		)
		fromV = sqlgraph.Neighbors(sv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtra queries the extra edge of a SpoolVendor.
func (c *SpoolVendorClient) QueryExtra(sv *SpoolVendor) *VendorFieldQuery {
	query := (&VendorFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(spoolvendor.Table, spoolvendor.FieldID, id),
			sqlgraph.To(vendorfield.Table, vendorfield.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, spoolvendor.ExtraTable, spoolvendor.ExtraColumn),
		)
		fromV = sqlgraph.Neighbors(sv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SpoolVendorClient) Hooks() []Hook {
	return c.hooks.SpoolVendor
}

// Interceptors returns the client interceptors.
func (c *SpoolVendorClient) Interceptors() []Interceptor {
	return c.inters.SpoolVendor
}

func (c *SpoolVendorClient) mutate(ctx context.Context, m *SpoolVendorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SpoolVendorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SpoolVendorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SpoolVendorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SpoolVendorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SpoolVendor mutation op: %q", m.Op())
	}
}

// VendorFieldClient is a client for the VendorField schema.
type VendorFieldClient struct {
	config
}

// NewVendorFieldClient returns a client for the VendorField from the given config.
func NewVendorFieldClient(c config) *VendorFieldClient {
	return &VendorFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vendorfield.Hooks(f(g(h())))`.
func (c *VendorFieldClient) Use(hooks ...Hook) {
	c.hooks.VendorField = append(c.hooks.VendorField, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vendorfield.Intercept(f(g(h())))`.
func (c *VendorFieldClient) Intercept(interceptors ...Interceptor) {
	c.inters.VendorField = append(c.inters.VendorField, interceptors...)
}

// Create returns a builder for creating a VendorField entity.
func (c *VendorFieldClient) Create() *VendorFieldCreate {
	mutation := newVendorFieldMutation(c.config, OpCreate)
	return &VendorFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VendorField entities.
func (c *VendorFieldClient) CreateBulk(builders ...*VendorFieldCreate) *VendorFieldCreateBulk {
	return &VendorFieldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VendorFieldClient) MapCreateBulk(slice any, setFunc func(*VendorFieldCreate, int)) *VendorFieldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VendorFieldCreateBulk{err: fmt.Errorf("calling to VendorFieldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VendorFieldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VendorFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VendorField.
func (c *VendorFieldClient) Update() *VendorFieldUpdate {
	mutation := newVendorFieldMutation(c.config, OpUpdate)
	return &VendorFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VendorFieldClient) UpdateOne(vf *VendorField) *VendorFieldUpdateOne {
	mutation := newVendorFieldMutation(c.config, OpUpdateOne, withVendorField(vf))
	return &VendorFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VendorFieldClient) UpdateOneID(id int) *VendorFieldUpdateOne {
	mutation := newVendorFieldMutation(c.config, OpUpdateOne, withVendorFieldID(id))
	return &VendorFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VendorField.
func (c *VendorFieldClient) Delete() *VendorFieldDelete {
	mutation := newVendorFieldMutation(c.config, OpDelete)
	return &VendorFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VendorFieldClient) DeleteOne(vf *VendorField) *VendorFieldDeleteOne {
	return c.DeleteOneID(vf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VendorFieldClient) DeleteOneID(id int) *VendorFieldDeleteOne {
	builder := c.Delete().Where(vendorfield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VendorFieldDeleteOne{builder}
}

// Query returns a query builder for VendorField.
func (c *VendorFieldClient) Query() *VendorFieldQuery {
	return &VendorFieldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVendorField},
		inters: c.Interceptors(),
	}
}

// Get returns a VendorField entity by its id.
func (c *VendorFieldClient) Get(ctx context.Context, id int) (*VendorField, error) {
	return c.Query().Where(vendorfield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VendorFieldClient) GetX(ctx context.Context, id int) *VendorField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVendor queries the vendor edge of a VendorField.
func (c *VendorFieldClient) QueryVendor(vf *VendorField) *SpoolVendorQuery {
	query := (&SpoolVendorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vendorfield.Table, vendorfield.FieldID, id),
			sqlgraph.To(spoolvendor.Table, spoolvendor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vendorfield.VendorTable, vendorfield.VendorColumn),
		)
		fromV = sqlgraph.Neighbors(vf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VendorFieldClient) Hooks() []Hook {
	return c.hooks.VendorField
}

// Interceptors returns the client interceptors.
func (c *VendorFieldClient) Interceptors() []Interceptor {
	return c.inters.VendorField
}

func (c *VendorFieldClient) mutate(ctx context.Context, m *VendorFieldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VendorFieldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VendorFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VendorFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VendorFieldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VendorField mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Filament, FilamentField, Setting, Spool, SpoolField, SpoolVendor,
		VendorField []ent.Hook
	}
	inters struct {
		Filament, FilamentField, Setting, Spool, SpoolField, SpoolVendor,
		VendorField []ent.Interceptor
	}
)
