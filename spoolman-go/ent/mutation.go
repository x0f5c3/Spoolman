// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"spoolman-go/ent/filament"
	"spoolman-go/ent/filamentfield"
	"spoolman-go/ent/predicate"
	"spoolman-go/ent/setting"
	"spoolman-go/ent/spool"
	"spoolman-go/ent/spoolfield"
	"spoolman-go/ent/spoolvendor"
	"spoolman-go/ent/vendorfield"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFilament      = "Filament"
	TypeFilamentField = "FilamentField"
	TypeSetting       = "Setting"
	TypeSpool         = "Spool"
	TypeSpoolField    = "SpoolField"
	TypeSpoolVendor   = "SpoolVendor"
	TypeVendorField   = "VendorField"
)

// FilamentMutation represents an operation that mutates the Filament nodes in the graph.
type FilamentMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	registered                *time.Time
	name                      *string
	material                  *string
	price                     *float32
	addprice                  *float32
	density                   *float32
	adddensity                *float32
	diameter                  *float32
	adddiameter               *float32
	weight                    *float32
	addweight                 *float32
	spool_weight              *float32
	addspool_weight           *float32
	article_number            *string
	comment                   *string
	settings_extruder_temp    *int
	addsettings_extruder_temp *int
	settings_bed_temp         *int
	addsettings_bed_temp      *int
	color_hex                 *string
	multi_color_hexes         *string
	multi_color_direction     *string
	external_id               *string
	clearedFields             map[string]struct{}
	vendor                    *int
	clearedvendor             bool
	spools                    map[int]struct{}
	removedspools             map[int]struct{}
	clearedspools             bool
	extra                     map[int]struct{}
	removedextra              map[int]struct{}
	clearedextra              bool
	done                      bool
	oldValue                  func(context.Context) (*Filament, error)
	predicates                []predicate.Filament
}

var _ ent.Mutation = (*FilamentMutation)(nil)

// filamentOption allows management of the mutation configuration using functional options.
type filamentOption func(*FilamentMutation)

// newFilamentMutation creates new mutation for the Filament entity.
func newFilamentMutation(c config, op Op, opts ...filamentOption) *FilamentMutation {
	m := &FilamentMutation{
		config:        c,
		op:            op,
		typ:           TypeFilament,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilamentID sets the ID field of the mutation.
func withFilamentID(id int) filamentOption {
	return func(m *FilamentMutation) {
		var (
			err   error
			once  sync.Once
			value *Filament
		)
		m.oldValue = func(ctx context.Context) (*Filament, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Filament.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilament sets the old Filament of the mutation.
func withFilament(node *Filament) filamentOption {
	return func(m *FilamentMutation) {
		m.oldValue = func(context.Context) (*Filament, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilamentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilamentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Filament entities.
func (m *FilamentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilamentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilamentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Filament.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRegistered sets the "registered" field.
func (m *FilamentMutation) SetRegistered(t time.Time) {
	m.registered = &t
}

// Registered returns the value of the "registered" field in the mutation.
func (m *FilamentMutation) Registered() (r time.Time, exists bool) {
	v := m.registered
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistered returns the old "registered" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldRegistered(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistered: %w", err)
	}
	return oldValue.Registered, nil
}

// ResetRegistered resets all changes to the "registered" field.
func (m *FilamentMutation) ResetRegistered() {
	m.registered = nil
}

// SetName sets the "name" field.
func (m *FilamentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FilamentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *FilamentMutation) ClearName() {
	m.name = nil
	m.clearedFields[filament.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *FilamentMutation) NameCleared() bool {
	_, ok := m.clearedFields[filament.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *FilamentMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, filament.FieldName)
}

// SetVendorID sets the "vendor_id" field.
func (m *FilamentMutation) SetVendorID(i int) {
	m.vendor = &i
}

// VendorID returns the value of the "vendor_id" field in the mutation.
func (m *FilamentMutation) VendorID() (r int, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorID returns the old "vendor_id" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldVendorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorID: %w", err)
	}
	return oldValue.VendorID, nil
}

// ClearVendorID clears the value of the "vendor_id" field.
func (m *FilamentMutation) ClearVendorID() {
	m.vendor = nil
	m.clearedFields[filament.FieldVendorID] = struct{}{}
}

// VendorIDCleared returns if the "vendor_id" field was cleared in this mutation.
func (m *FilamentMutation) VendorIDCleared() bool {
	_, ok := m.clearedFields[filament.FieldVendorID]
	return ok
}

// ResetVendorID resets all changes to the "vendor_id" field.
func (m *FilamentMutation) ResetVendorID() {
	m.vendor = nil
	delete(m.clearedFields, filament.FieldVendorID)
}

// SetMaterial sets the "material" field.
func (m *FilamentMutation) SetMaterial(s string) {
	m.material = &s
}

// Material returns the value of the "material" field in the mutation.
func (m *FilamentMutation) Material() (r string, exists bool) {
	v := m.material
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterial returns the old "material" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldMaterial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterial: %w", err)
	}
	return oldValue.Material, nil
}

// ClearMaterial clears the value of the "material" field.
func (m *FilamentMutation) ClearMaterial() {
	m.material = nil
	m.clearedFields[filament.FieldMaterial] = struct{}{}
}

// MaterialCleared returns if the "material" field was cleared in this mutation.
func (m *FilamentMutation) MaterialCleared() bool {
	_, ok := m.clearedFields[filament.FieldMaterial]
	return ok
}

// ResetMaterial resets all changes to the "material" field.
func (m *FilamentMutation) ResetMaterial() {
	m.material = nil
	delete(m.clearedFields, filament.FieldMaterial)
}

// SetPrice sets the "price" field.
func (m *FilamentMutation) SetPrice(f float32) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *FilamentMutation) Price() (r float32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldPrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *FilamentMutation) AddPrice(f float32) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *FilamentMutation) AddedPrice() (r float32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *FilamentMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[filament.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *FilamentMutation) PriceCleared() bool {
	_, ok := m.clearedFields[filament.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *FilamentMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, filament.FieldPrice)
}

// SetDensity sets the "density" field.
func (m *FilamentMutation) SetDensity(f float32) {
	m.density = &f
	m.adddensity = nil
}

// Density returns the value of the "density" field in the mutation.
func (m *FilamentMutation) Density() (r float32, exists bool) {
	v := m.density
	if v == nil {
		return
	}
	return *v, true
}

// OldDensity returns the old "density" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldDensity(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDensity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDensity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDensity: %w", err)
	}
	return oldValue.Density, nil
}

// AddDensity adds f to the "density" field.
func (m *FilamentMutation) AddDensity(f float32) {
	if m.adddensity != nil {
		*m.adddensity += f
	} else {
		m.adddensity = &f
	}
}

// AddedDensity returns the value that was added to the "density" field in this mutation.
func (m *FilamentMutation) AddedDensity() (r float32, exists bool) {
	v := m.adddensity
	if v == nil {
		return
	}
	return *v, true
}

// ResetDensity resets all changes to the "density" field.
func (m *FilamentMutation) ResetDensity() {
	m.density = nil
	m.adddensity = nil
}

// SetDiameter sets the "diameter" field.
func (m *FilamentMutation) SetDiameter(f float32) {
	m.diameter = &f
	m.adddiameter = nil
}

// Diameter returns the value of the "diameter" field in the mutation.
func (m *FilamentMutation) Diameter() (r float32, exists bool) {
	v := m.diameter
	if v == nil {
		return
	}
	return *v, true
}

// OldDiameter returns the old "diameter" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldDiameter(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiameter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiameter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiameter: %w", err)
	}
	return oldValue.Diameter, nil
}

// AddDiameter adds f to the "diameter" field.
func (m *FilamentMutation) AddDiameter(f float32) {
	if m.adddiameter != nil {
		*m.adddiameter += f
	} else {
		m.adddiameter = &f
	}
}

// AddedDiameter returns the value that was added to the "diameter" field in this mutation.
func (m *FilamentMutation) AddedDiameter() (r float32, exists bool) {
	v := m.adddiameter
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiameter resets all changes to the "diameter" field.
func (m *FilamentMutation) ResetDiameter() {
	m.diameter = nil
	m.adddiameter = nil
}

// SetWeight sets the "weight" field.
func (m *FilamentMutation) SetWeight(f float32) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *FilamentMutation) Weight() (r float32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *FilamentMutation) AddWeight(f float32) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *FilamentMutation) AddedWeight() (r float32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *FilamentMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[filament.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *FilamentMutation) WeightCleared() bool {
	_, ok := m.clearedFields[filament.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *FilamentMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, filament.FieldWeight)
}

// SetSpoolWeight sets the "spool_weight" field.
func (m *FilamentMutation) SetSpoolWeight(f float32) {
	m.spool_weight = &f
	m.addspool_weight = nil
}

// SpoolWeight returns the value of the "spool_weight" field in the mutation.
func (m *FilamentMutation) SpoolWeight() (r float32, exists bool) {
	v := m.spool_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldSpoolWeight returns the old "spool_weight" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldSpoolWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpoolWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpoolWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpoolWeight: %w", err)
	}
	return oldValue.SpoolWeight, nil
}

// AddSpoolWeight adds f to the "spool_weight" field.
func (m *FilamentMutation) AddSpoolWeight(f float32) {
	if m.addspool_weight != nil {
		*m.addspool_weight += f
	} else {
		m.addspool_weight = &f
	}
}

// AddedSpoolWeight returns the value that was added to the "spool_weight" field in this mutation.
func (m *FilamentMutation) AddedSpoolWeight() (r float32, exists bool) {
	v := m.addspool_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpoolWeight clears the value of the "spool_weight" field.
func (m *FilamentMutation) ClearSpoolWeight() {
	m.spool_weight = nil
	m.addspool_weight = nil
	m.clearedFields[filament.FieldSpoolWeight] = struct{}{}
}

// SpoolWeightCleared returns if the "spool_weight" field was cleared in this mutation.
func (m *FilamentMutation) SpoolWeightCleared() bool {
	_, ok := m.clearedFields[filament.FieldSpoolWeight]
	return ok
}

// ResetSpoolWeight resets all changes to the "spool_weight" field.
func (m *FilamentMutation) ResetSpoolWeight() {
	m.spool_weight = nil
	m.addspool_weight = nil
	delete(m.clearedFields, filament.FieldSpoolWeight)
}

// SetArticleNumber sets the "article_number" field.
func (m *FilamentMutation) SetArticleNumber(s string) {
	m.article_number = &s
}

// ArticleNumber returns the value of the "article_number" field in the mutation.
func (m *FilamentMutation) ArticleNumber() (r string, exists bool) {
	v := m.article_number
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleNumber returns the old "article_number" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldArticleNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleNumber: %w", err)
	}
	return oldValue.ArticleNumber, nil
}

// ClearArticleNumber clears the value of the "article_number" field.
func (m *FilamentMutation) ClearArticleNumber() {
	m.article_number = nil
	m.clearedFields[filament.FieldArticleNumber] = struct{}{}
}

// ArticleNumberCleared returns if the "article_number" field was cleared in this mutation.
func (m *FilamentMutation) ArticleNumberCleared() bool {
	_, ok := m.clearedFields[filament.FieldArticleNumber]
	return ok
}

// ResetArticleNumber resets all changes to the "article_number" field.
func (m *FilamentMutation) ResetArticleNumber() {
	m.article_number = nil
	delete(m.clearedFields, filament.FieldArticleNumber)
}

// SetComment sets the "comment" field.
func (m *FilamentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *FilamentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *FilamentMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[filament.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *FilamentMutation) CommentCleared() bool {
	_, ok := m.clearedFields[filament.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *FilamentMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, filament.FieldComment)
}

// SetSettingsExtruderTemp sets the "settings_extruder_temp" field.
func (m *FilamentMutation) SetSettingsExtruderTemp(i int) {
	m.settings_extruder_temp = &i
	m.addsettings_extruder_temp = nil
}

// SettingsExtruderTemp returns the value of the "settings_extruder_temp" field in the mutation.
func (m *FilamentMutation) SettingsExtruderTemp() (r int, exists bool) {
	v := m.settings_extruder_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingsExtruderTemp returns the old "settings_extruder_temp" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldSettingsExtruderTemp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingsExtruderTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingsExtruderTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingsExtruderTemp: %w", err)
	}
	return oldValue.SettingsExtruderTemp, nil
}

// AddSettingsExtruderTemp adds i to the "settings_extruder_temp" field.
func (m *FilamentMutation) AddSettingsExtruderTemp(i int) {
	if m.addsettings_extruder_temp != nil {
		*m.addsettings_extruder_temp += i
	} else {
		m.addsettings_extruder_temp = &i
	}
}

// AddedSettingsExtruderTemp returns the value that was added to the "settings_extruder_temp" field in this mutation.
func (m *FilamentMutation) AddedSettingsExtruderTemp() (r int, exists bool) {
	v := m.addsettings_extruder_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearSettingsExtruderTemp clears the value of the "settings_extruder_temp" field.
func (m *FilamentMutation) ClearSettingsExtruderTemp() {
	m.settings_extruder_temp = nil
	m.addsettings_extruder_temp = nil
	m.clearedFields[filament.FieldSettingsExtruderTemp] = struct{}{}
}

// SettingsExtruderTempCleared returns if the "settings_extruder_temp" field was cleared in this mutation.
func (m *FilamentMutation) SettingsExtruderTempCleared() bool {
	_, ok := m.clearedFields[filament.FieldSettingsExtruderTemp]
	return ok
}

// ResetSettingsExtruderTemp resets all changes to the "settings_extruder_temp" field.
func (m *FilamentMutation) ResetSettingsExtruderTemp() {
	m.settings_extruder_temp = nil
	m.addsettings_extruder_temp = nil
	delete(m.clearedFields, filament.FieldSettingsExtruderTemp)
}

// SetSettingsBedTemp sets the "settings_bed_temp" field.
func (m *FilamentMutation) SetSettingsBedTemp(i int) {
	m.settings_bed_temp = &i
	m.addsettings_bed_temp = nil
}

// SettingsBedTemp returns the value of the "settings_bed_temp" field in the mutation.
func (m *FilamentMutation) SettingsBedTemp() (r int, exists bool) {
	v := m.settings_bed_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingsBedTemp returns the old "settings_bed_temp" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldSettingsBedTemp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingsBedTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingsBedTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingsBedTemp: %w", err)
	}
	return oldValue.SettingsBedTemp, nil
}

// AddSettingsBedTemp adds i to the "settings_bed_temp" field.
func (m *FilamentMutation) AddSettingsBedTemp(i int) {
	if m.addsettings_bed_temp != nil {
		*m.addsettings_bed_temp += i
	} else {
		m.addsettings_bed_temp = &i
	}
}

// AddedSettingsBedTemp returns the value that was added to the "settings_bed_temp" field in this mutation.
func (m *FilamentMutation) AddedSettingsBedTemp() (r int, exists bool) {
	v := m.addsettings_bed_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearSettingsBedTemp clears the value of the "settings_bed_temp" field.
func (m *FilamentMutation) ClearSettingsBedTemp() {
	m.settings_bed_temp = nil
	m.addsettings_bed_temp = nil
	m.clearedFields[filament.FieldSettingsBedTemp] = struct{}{}
}

// SettingsBedTempCleared returns if the "settings_bed_temp" field was cleared in this mutation.
func (m *FilamentMutation) SettingsBedTempCleared() bool {
	_, ok := m.clearedFields[filament.FieldSettingsBedTemp]
	return ok
}

// ResetSettingsBedTemp resets all changes to the "settings_bed_temp" field.
func (m *FilamentMutation) ResetSettingsBedTemp() {
	m.settings_bed_temp = nil
	m.addsettings_bed_temp = nil
	delete(m.clearedFields, filament.FieldSettingsBedTemp)
}

// SetColorHex sets the "color_hex" field.
func (m *FilamentMutation) SetColorHex(s string) {
	m.color_hex = &s
}

// ColorHex returns the value of the "color_hex" field in the mutation.
func (m *FilamentMutation) ColorHex() (r string, exists bool) {
	v := m.color_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldColorHex returns the old "color_hex" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldColorHex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorHex: %w", err)
	}
	return oldValue.ColorHex, nil
}

// ClearColorHex clears the value of the "color_hex" field.
func (m *FilamentMutation) ClearColorHex() {
	m.color_hex = nil
	m.clearedFields[filament.FieldColorHex] = struct{}{}
}

// ColorHexCleared returns if the "color_hex" field was cleared in this mutation.
func (m *FilamentMutation) ColorHexCleared() bool {
	_, ok := m.clearedFields[filament.FieldColorHex]
	return ok
}

// ResetColorHex resets all changes to the "color_hex" field.
func (m *FilamentMutation) ResetColorHex() {
	m.color_hex = nil
	delete(m.clearedFields, filament.FieldColorHex)
}

// SetMultiColorHexes sets the "multi_color_hexes" field.
func (m *FilamentMutation) SetMultiColorHexes(s string) {
	m.multi_color_hexes = &s
}

// MultiColorHexes returns the value of the "multi_color_hexes" field in the mutation.
func (m *FilamentMutation) MultiColorHexes() (r string, exists bool) {
	v := m.multi_color_hexes
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiColorHexes returns the old "multi_color_hexes" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldMultiColorHexes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiColorHexes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiColorHexes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiColorHexes: %w", err)
	}
	return oldValue.MultiColorHexes, nil
}

// ClearMultiColorHexes clears the value of the "multi_color_hexes" field.
func (m *FilamentMutation) ClearMultiColorHexes() {
	m.multi_color_hexes = nil
	m.clearedFields[filament.FieldMultiColorHexes] = struct{}{}
}

// MultiColorHexesCleared returns if the "multi_color_hexes" field was cleared in this mutation.
func (m *FilamentMutation) MultiColorHexesCleared() bool {
	_, ok := m.clearedFields[filament.FieldMultiColorHexes]
	return ok
}

// ResetMultiColorHexes resets all changes to the "multi_color_hexes" field.
func (m *FilamentMutation) ResetMultiColorHexes() {
	m.multi_color_hexes = nil
	delete(m.clearedFields, filament.FieldMultiColorHexes)
}

// SetMultiColorDirection sets the "multi_color_direction" field.
func (m *FilamentMutation) SetMultiColorDirection(s string) {
	m.multi_color_direction = &s
}

// MultiColorDirection returns the value of the "multi_color_direction" field in the mutation.
func (m *FilamentMutation) MultiColorDirection() (r string, exists bool) {
	v := m.multi_color_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiColorDirection returns the old "multi_color_direction" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldMultiColorDirection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiColorDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiColorDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiColorDirection: %w", err)
	}
	return oldValue.MultiColorDirection, nil
}

// ClearMultiColorDirection clears the value of the "multi_color_direction" field.
func (m *FilamentMutation) ClearMultiColorDirection() {
	m.multi_color_direction = nil
	m.clearedFields[filament.FieldMultiColorDirection] = struct{}{}
}

// MultiColorDirectionCleared returns if the "multi_color_direction" field was cleared in this mutation.
func (m *FilamentMutation) MultiColorDirectionCleared() bool {
	_, ok := m.clearedFields[filament.FieldMultiColorDirection]
	return ok
}

// ResetMultiColorDirection resets all changes to the "multi_color_direction" field.
func (m *FilamentMutation) ResetMultiColorDirection() {
	m.multi_color_direction = nil
	delete(m.clearedFields, filament.FieldMultiColorDirection)
}

// SetExternalID sets the "external_id" field.
func (m *FilamentMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *FilamentMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Filament entity.
// If the Filament object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *FilamentMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[filament.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *FilamentMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[filament.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *FilamentMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, filament.FieldExternalID)
}

// ClearVendor clears the "vendor" edge to the SpoolVendor entity.
func (m *FilamentMutation) ClearVendor() {
	m.clearedvendor = true
	m.clearedFields[filament.FieldVendorID] = struct{}{}
}

// VendorCleared reports if the "vendor" edge to the SpoolVendor entity was cleared.
func (m *FilamentMutation) VendorCleared() bool {
	return m.VendorIDCleared() || m.clearedvendor
}

// VendorIDs returns the "vendor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VendorID instead. It exists only for internal usage by the builders.
func (m *FilamentMutation) VendorIDs() (ids []int) {
	if id := m.vendor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendor resets all changes to the "vendor" edge.
func (m *FilamentMutation) ResetVendor() {
	m.vendor = nil
	m.clearedvendor = false
}

// AddSpoolIDs adds the "spools" edge to the Spool entity by ids.
func (m *FilamentMutation) AddSpoolIDs(ids ...int) {
	if m.spools == nil {
		m.spools = make(map[int]struct{})
	}
	for i := range ids {
		m.spools[ids[i]] = struct{}{}
	}
}

// ClearSpools clears the "spools" edge to the Spool entity.
func (m *FilamentMutation) ClearSpools() {
	m.clearedspools = true
}

// SpoolsCleared reports if the "spools" edge to the Spool entity was cleared.
func (m *FilamentMutation) SpoolsCleared() bool {
	return m.clearedspools
}

// RemoveSpoolIDs removes the "spools" edge to the Spool entity by IDs.
func (m *FilamentMutation) RemoveSpoolIDs(ids ...int) {
	if m.removedspools == nil {
		m.removedspools = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.spools, ids[i])
		m.removedspools[ids[i]] = struct{}{}
	}
}

// RemovedSpools returns the removed IDs of the "spools" edge to the Spool entity.
func (m *FilamentMutation) RemovedSpoolsIDs() (ids []int) {
	for id := range m.removedspools {
		ids = append(ids, id)
	}
	return
}

// SpoolsIDs returns the "spools" edge IDs in the mutation.
func (m *FilamentMutation) SpoolsIDs() (ids []int) {
	for id := range m.spools {
		ids = append(ids, id)
	}
	return
}

// ResetSpools resets all changes to the "spools" edge.
func (m *FilamentMutation) ResetSpools() {
	m.spools = nil
	m.clearedspools = false
	m.removedspools = nil
}

// AddExtraIDs adds the "extra" edge to the FilamentField entity by ids.
func (m *FilamentMutation) AddExtraIDs(ids ...int) {
	if m.extra == nil {
		m.extra = make(map[int]struct{})
	}
	for i := range ids {
		m.extra[ids[i]] = struct{}{}
	}
}

// ClearExtra clears the "extra" edge to the FilamentField entity.
func (m *FilamentMutation) ClearExtra() {
	m.clearedextra = true
}

// ExtraCleared reports if the "extra" edge to the FilamentField entity was cleared.
func (m *FilamentMutation) ExtraCleared() bool {
	return m.clearedextra
}

// RemoveExtraIDs removes the "extra" edge to the FilamentField entity by IDs.
func (m *FilamentMutation) RemoveExtraIDs(ids ...int) {
	if m.removedextra == nil {
		m.removedextra = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.extra, ids[i])
		m.removedextra[ids[i]] = struct{}{}
	}
}

// RemovedExtra returns the removed IDs of the "extra" edge to the FilamentField entity.
func (m *FilamentMutation) RemovedExtraIDs() (ids []int) {
	for id := range m.removedextra {
		ids = append(ids, id)
	}
	return
}

// ExtraIDs returns the "extra" edge IDs in the mutation.
func (m *FilamentMutation) ExtraIDs() (ids []int) {
	for id := range m.extra {
		ids = append(ids, id)
	}
	return
}

// ResetExtra resets all changes to the "extra" edge.
func (m *FilamentMutation) ResetExtra() {
	m.extra = nil
	m.clearedextra = false
	m.removedextra = nil
}

// Where appends a list predicates to the FilamentMutation builder.
func (m *FilamentMutation) Where(ps ...predicate.Filament) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilamentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilamentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Filament, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilamentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilamentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Filament).
func (m *FilamentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilamentMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.registered != nil {
		fields = append(fields, filament.FieldRegistered)
	}
	if m.name != nil {
		fields = append(fields, filament.FieldName)
	}
	if m.vendor != nil {
		fields = append(fields, filament.FieldVendorID)
	}
	if m.material != nil {
		fields = append(fields, filament.FieldMaterial)
	}
	if m.price != nil {
		fields = append(fields, filament.FieldPrice)
	}
	if m.density != nil {
		fields = append(fields, filament.FieldDensity)
	}
	if m.diameter != nil {
		fields = append(fields, filament.FieldDiameter)
	}
	if m.weight != nil {
		fields = append(fields, filament.FieldWeight)
	}
	if m.spool_weight != nil {
		fields = append(fields, filament.FieldSpoolWeight)
	}
	if m.article_number != nil {
		fields = append(fields, filament.FieldArticleNumber)
	}
	if m.comment != nil {
		fields = append(fields, filament.FieldComment)
	}
	if m.settings_extruder_temp != nil {
		fields = append(fields, filament.FieldSettingsExtruderTemp)
	}
	if m.settings_bed_temp != nil {
		fields = append(fields, filament.FieldSettingsBedTemp)
	}
	if m.color_hex != nil {
		fields = append(fields, filament.FieldColorHex)
	}
	if m.multi_color_hexes != nil {
		fields = append(fields, filament.FieldMultiColorHexes)
	}
	if m.multi_color_direction != nil {
		fields = append(fields, filament.FieldMultiColorDirection)
	}
	if m.external_id != nil {
		fields = append(fields, filament.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilamentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filament.FieldRegistered:
		return m.Registered()
	case filament.FieldName:
		return m.Name()
	case filament.FieldVendorID:
		return m.VendorID()
	case filament.FieldMaterial:
		return m.Material()
	case filament.FieldPrice:
		return m.Price()
	case filament.FieldDensity:
		return m.Density()
	case filament.FieldDiameter:
		return m.Diameter()
	case filament.FieldWeight:
		return m.Weight()
	case filament.FieldSpoolWeight:
		return m.SpoolWeight()
	case filament.FieldArticleNumber:
		return m.ArticleNumber()
	case filament.FieldComment:
		return m.Comment()
	case filament.FieldSettingsExtruderTemp:
		return m.SettingsExtruderTemp()
	case filament.FieldSettingsBedTemp:
		return m.SettingsBedTemp()
	case filament.FieldColorHex:
		return m.ColorHex()
	case filament.FieldMultiColorHexes:
		return m.MultiColorHexes()
	case filament.FieldMultiColorDirection:
		return m.MultiColorDirection()
	case filament.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilamentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filament.FieldRegistered:
		return m.OldRegistered(ctx)
	case filament.FieldName:
		return m.OldName(ctx)
	case filament.FieldVendorID:
		return m.OldVendorID(ctx)
	case filament.FieldMaterial:
		return m.OldMaterial(ctx)
	case filament.FieldPrice:
		return m.OldPrice(ctx)
	case filament.FieldDensity:
		return m.OldDensity(ctx)
	case filament.FieldDiameter:
		return m.OldDiameter(ctx)
	case filament.FieldWeight:
		return m.OldWeight(ctx)
	case filament.FieldSpoolWeight:
		return m.OldSpoolWeight(ctx)
	case filament.FieldArticleNumber:
		return m.OldArticleNumber(ctx)
	case filament.FieldComment:
		return m.OldComment(ctx)
	case filament.FieldSettingsExtruderTemp:
		return m.OldSettingsExtruderTemp(ctx)
	case filament.FieldSettingsBedTemp:
		return m.OldSettingsBedTemp(ctx)
	case filament.FieldColorHex:
		return m.OldColorHex(ctx)
	case filament.FieldMultiColorHexes:
		return m.OldMultiColorHexes(ctx)
	case filament.FieldMultiColorDirection:
		return m.OldMultiColorDirection(ctx)
	case filament.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown Filament field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilamentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filament.FieldRegistered:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistered(v)
		return nil
	case filament.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case filament.FieldVendorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorID(v)
		return nil
	case filament.FieldMaterial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterial(v)
		return nil
	case filament.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case filament.FieldDensity:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDensity(v)
		return nil
	case filament.FieldDiameter:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiameter(v)
		return nil
	case filament.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case filament.FieldSpoolWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpoolWeight(v)
		return nil
	case filament.FieldArticleNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleNumber(v)
		return nil
	case filament.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case filament.FieldSettingsExtruderTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingsExtruderTemp(v)
		return nil
	case filament.FieldSettingsBedTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingsBedTemp(v)
		return nil
	case filament.FieldColorHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorHex(v)
		return nil
	case filament.FieldMultiColorHexes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiColorHexes(v)
		return nil
	case filament.FieldMultiColorDirection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiColorDirection(v)
		return nil
	case filament.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Filament field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilamentMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, filament.FieldPrice)
	}
	if m.adddensity != nil {
		fields = append(fields, filament.FieldDensity)
	}
	if m.adddiameter != nil {
		fields = append(fields, filament.FieldDiameter)
	}
	if m.addweight != nil {
		fields = append(fields, filament.FieldWeight)
	}
	if m.addspool_weight != nil {
		fields = append(fields, filament.FieldSpoolWeight)
	}
	if m.addsettings_extruder_temp != nil {
		fields = append(fields, filament.FieldSettingsExtruderTemp)
	}
	if m.addsettings_bed_temp != nil {
		fields = append(fields, filament.FieldSettingsBedTemp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilamentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filament.FieldPrice:
		return m.AddedPrice()
	case filament.FieldDensity:
		return m.AddedDensity()
	case filament.FieldDiameter:
		return m.AddedDiameter()
	case filament.FieldWeight:
		return m.AddedWeight()
	case filament.FieldSpoolWeight:
		return m.AddedSpoolWeight()
	case filament.FieldSettingsExtruderTemp:
		return m.AddedSettingsExtruderTemp()
	case filament.FieldSettingsBedTemp:
		return m.AddedSettingsBedTemp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilamentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filament.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case filament.FieldDensity:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDensity(v)
		return nil
	case filament.FieldDiameter:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiameter(v)
		return nil
	case filament.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case filament.FieldSpoolWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpoolWeight(v)
		return nil
	case filament.FieldSettingsExtruderTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettingsExtruderTemp(v)
		return nil
	case filament.FieldSettingsBedTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettingsBedTemp(v)
		return nil
	}
	return fmt.Errorf("unknown Filament numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilamentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filament.FieldName) {
		fields = append(fields, filament.FieldName)
	}
	if m.FieldCleared(filament.FieldVendorID) {
		fields = append(fields, filament.FieldVendorID)
	}
	if m.FieldCleared(filament.FieldMaterial) {
		fields = append(fields, filament.FieldMaterial)
	}
	if m.FieldCleared(filament.FieldPrice) {
		fields = append(fields, filament.FieldPrice)
	}
	if m.FieldCleared(filament.FieldWeight) {
		fields = append(fields, filament.FieldWeight)
	}
	if m.FieldCleared(filament.FieldSpoolWeight) {
		fields = append(fields, filament.FieldSpoolWeight)
	}
	if m.FieldCleared(filament.FieldArticleNumber) {
		fields = append(fields, filament.FieldArticleNumber)
	}
	if m.FieldCleared(filament.FieldComment) {
		fields = append(fields, filament.FieldComment)
	}
	if m.FieldCleared(filament.FieldSettingsExtruderTemp) {
		fields = append(fields, filament.FieldSettingsExtruderTemp)
	}
	if m.FieldCleared(filament.FieldSettingsBedTemp) {
		fields = append(fields, filament.FieldSettingsBedTemp)
	}
	if m.FieldCleared(filament.FieldColorHex) {
		fields = append(fields, filament.FieldColorHex)
	}
	if m.FieldCleared(filament.FieldMultiColorHexes) {
		fields = append(fields, filament.FieldMultiColorHexes)
	}
	if m.FieldCleared(filament.FieldMultiColorDirection) {
		fields = append(fields, filament.FieldMultiColorDirection)
	}
	if m.FieldCleared(filament.FieldExternalID) {
		fields = append(fields, filament.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilamentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilamentMutation) ClearField(name string) error {
	switch name {
	case filament.FieldName:
		m.ClearName()
		return nil
	case filament.FieldVendorID:
		m.ClearVendorID()
		return nil
	case filament.FieldMaterial:
		m.ClearMaterial()
		return nil
	case filament.FieldPrice:
		m.ClearPrice()
		return nil
	case filament.FieldWeight:
		m.ClearWeight()
		return nil
	case filament.FieldSpoolWeight:
		m.ClearSpoolWeight()
		return nil
	case filament.FieldArticleNumber:
		m.ClearArticleNumber()
		return nil
	case filament.FieldComment:
		m.ClearComment()
		return nil
	case filament.FieldSettingsExtruderTemp:
		m.ClearSettingsExtruderTemp()
		return nil
	case filament.FieldSettingsBedTemp:
		m.ClearSettingsBedTemp()
		return nil
	case filament.FieldColorHex:
		m.ClearColorHex()
		return nil
	case filament.FieldMultiColorHexes:
		m.ClearMultiColorHexes()
		return nil
	case filament.FieldMultiColorDirection:
		m.ClearMultiColorDirection()
		return nil
	case filament.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Filament nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilamentMutation) ResetField(name string) error {
	switch name {
	case filament.FieldRegistered:
		m.ResetRegistered()
		return nil
	case filament.FieldName:
		m.ResetName()
		return nil
	case filament.FieldVendorID:
		m.ResetVendorID()
		return nil
	case filament.FieldMaterial:
		m.ResetMaterial()
		return nil
	case filament.FieldPrice:
		m.ResetPrice()
		return nil
	case filament.FieldDensity:
		m.ResetDensity()
		return nil
	case filament.FieldDiameter:
		m.ResetDiameter()
		return nil
	case filament.FieldWeight:
		m.ResetWeight()
		return nil
	case filament.FieldSpoolWeight:
		m.ResetSpoolWeight()
		return nil
	case filament.FieldArticleNumber:
		m.ResetArticleNumber()
		return nil
	case filament.FieldComment:
		m.ResetComment()
		return nil
	case filament.FieldSettingsExtruderTemp:
		m.ResetSettingsExtruderTemp()
		return nil
	case filament.FieldSettingsBedTemp:
		m.ResetSettingsBedTemp()
		return nil
	case filament.FieldColorHex:
		m.ResetColorHex()
		return nil
	case filament.FieldMultiColorHexes:
		m.ResetMultiColorHexes()
		return nil
	case filament.FieldMultiColorDirection:
		m.ResetMultiColorDirection()
		return nil
	case filament.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown Filament field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilamentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.vendor != nil {
		edges = append(edges, filament.EdgeVendor)
	}
	if m.spools != nil {
		edges = append(edges, filament.EdgeSpools)
	}
	if m.extra != nil {
		edges = append(edges, filament.EdgeExtra)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilamentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filament.EdgeVendor:
		if id := m.vendor; id != nil {
			return []ent.Value{*id}
		}
	case filament.EdgeSpools:
		ids := make([]ent.Value, 0, len(m.spools))
		for id := range m.spools {
			ids = append(ids, id)
		}
		return ids
	case filament.EdgeExtra:
		ids := make([]ent.Value, 0, len(m.extra))
		for id := range m.extra {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilamentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedspools != nil {
		edges = append(edges, filament.EdgeSpools)
	}
	if m.removedextra != nil {
		edges = append(edges, filament.EdgeExtra)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilamentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filament.EdgeSpools:
		ids := make([]ent.Value, 0, len(m.removedspools))
		for id := range m.removedspools {
			ids = append(ids, id)
		}
		return ids
	case filament.EdgeExtra:
		ids := make([]ent.Value, 0, len(m.removedextra))
		for id := range m.removedextra {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilamentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedvendor {
		edges = append(edges, filament.EdgeVendor)
	}
	if m.clearedspools {
		edges = append(edges, filament.EdgeSpools)
	}
	if m.clearedextra {
		edges = append(edges, filament.EdgeExtra)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilamentMutation) EdgeCleared(name string) bool {
	switch name {
	case filament.EdgeVendor:
		return m.clearedvendor
	case filament.EdgeSpools:
		return m.clearedspools
	case filament.EdgeExtra:
		return m.clearedextra
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilamentMutation) ClearEdge(name string) error {
	switch name {
	case filament.EdgeVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown Filament unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilamentMutation) ResetEdge(name string) error {
	switch name {
	case filament.EdgeVendor:
		m.ResetVendor()
		return nil
	case filament.EdgeSpools:
		m.ResetSpools()
		return nil
	case filament.EdgeExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown Filament edge %s", name)
}

// FilamentFieldMutation represents an operation that mutates the FilamentField nodes in the graph.
type FilamentFieldMutation struct {
	config
	op              Op
	typ             string
	id              *int
	key             *string
	value           *string
	clearedFields   map[string]struct{}
	filament        *int
	clearedfilament bool
	done            bool
	oldValue        func(context.Context) (*FilamentField, error)
	predicates      []predicate.FilamentField
}

var _ ent.Mutation = (*FilamentFieldMutation)(nil)

// filamentfieldOption allows management of the mutation configuration using functional options.
type filamentfieldOption func(*FilamentFieldMutation)

// newFilamentFieldMutation creates new mutation for the FilamentField entity.
func newFilamentFieldMutation(c config, op Op, opts ...filamentfieldOption) *FilamentFieldMutation {
	m := &FilamentFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeFilamentField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilamentFieldID sets the ID field of the mutation.
func withFilamentFieldID(id int) filamentfieldOption {
	return func(m *FilamentFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *FilamentField
		)
		m.oldValue = func(ctx context.Context) (*FilamentField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FilamentField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilamentField sets the old FilamentField of the mutation.
func withFilamentField(node *FilamentField) filamentfieldOption {
	return func(m *FilamentFieldMutation) {
		m.oldValue = func(context.Context) (*FilamentField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilamentFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilamentFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilamentFieldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilamentFieldMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FilamentField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFilamentID sets the "filament_id" field.
func (m *FilamentFieldMutation) SetFilamentID(i int) {
	m.filament = &i
}

// FilamentID returns the value of the "filament_id" field in the mutation.
func (m *FilamentFieldMutation) FilamentID() (r int, exists bool) {
	v := m.filament
	if v == nil {
		return
	}
	return *v, true
}

// OldFilamentID returns the old "filament_id" field's value of the FilamentField entity.
// If the FilamentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentFieldMutation) OldFilamentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilamentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilamentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilamentID: %w", err)
	}
	return oldValue.FilamentID, nil
}

// ResetFilamentID resets all changes to the "filament_id" field.
func (m *FilamentFieldMutation) ResetFilamentID() {
	m.filament = nil
}

// SetKey sets the "key" field.
func (m *FilamentFieldMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FilamentFieldMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the FilamentField entity.
// If the FilamentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentFieldMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FilamentFieldMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *FilamentFieldMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *FilamentFieldMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the FilamentField entity.
// If the FilamentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilamentFieldMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *FilamentFieldMutation) ResetValue() {
	m.value = nil
}

// ClearFilament clears the "filament" edge to the Filament entity.
func (m *FilamentFieldMutation) ClearFilament() {
	m.clearedfilament = true
	m.clearedFields[filamentfield.FieldFilamentID] = struct{}{}
}

// FilamentCleared reports if the "filament" edge to the Filament entity was cleared.
func (m *FilamentFieldMutation) FilamentCleared() bool {
	return m.clearedfilament
}

// FilamentIDs returns the "filament" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FilamentID instead. It exists only for internal usage by the builders.
func (m *FilamentFieldMutation) FilamentIDs() (ids []int) {
	if id := m.filament; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFilament resets all changes to the "filament" edge.
func (m *FilamentFieldMutation) ResetFilament() {
	m.filament = nil
	m.clearedfilament = false
}

// Where appends a list predicates to the FilamentFieldMutation builder.
func (m *FilamentFieldMutation) Where(ps ...predicate.FilamentField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilamentFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilamentFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FilamentField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilamentFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilamentFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FilamentField).
func (m *FilamentFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilamentFieldMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.filament != nil {
		fields = append(fields, filamentfield.FieldFilamentID)
	}
	if m.key != nil {
		fields = append(fields, filamentfield.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, filamentfield.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilamentFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filamentfield.FieldFilamentID:
		return m.FilamentID()
	case filamentfield.FieldKey:
		return m.Key()
	case filamentfield.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilamentFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filamentfield.FieldFilamentID:
		return m.OldFilamentID(ctx)
	case filamentfield.FieldKey:
		return m.OldKey(ctx)
	case filamentfield.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown FilamentField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilamentFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filamentfield.FieldFilamentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilamentID(v)
		return nil
	case filamentfield.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case filamentfield.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown FilamentField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilamentFieldMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilamentFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilamentFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FilamentField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilamentFieldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilamentFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilamentFieldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FilamentField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilamentFieldMutation) ResetField(name string) error {
	switch name {
	case filamentfield.FieldFilamentID:
		m.ResetFilamentID()
		return nil
	case filamentfield.FieldKey:
		m.ResetKey()
		return nil
	case filamentfield.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown FilamentField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilamentFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.filament != nil {
		edges = append(edges, filamentfield.EdgeFilament)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilamentFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filamentfield.EdgeFilament:
		if id := m.filament; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilamentFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilamentFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilamentFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfilament {
		edges = append(edges, filamentfield.EdgeFilament)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilamentFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case filamentfield.EdgeFilament:
		return m.clearedfilament
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilamentFieldMutation) ClearEdge(name string) error {
	switch name {
	case filamentfield.EdgeFilament:
		m.ClearFilament()
		return nil
	}
	return fmt.Errorf("unknown FilamentField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilamentFieldMutation) ResetEdge(name string) error {
	switch name {
	case filamentfield.EdgeFilament:
		m.ResetFilament()
		return nil
	}
	return fmt.Errorf("unknown FilamentField edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *string
	last_updated  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *SettingMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *SettingMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *SettingMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.last_updated != nil {
		fields = append(fields, setting.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldKey:
		return m.Key()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SpoolMutation represents an operation that mutates the Spool nodes in the graph.
type SpoolMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	registered          *time.Time
	first_used          *time.Time
	last_used           *time.Time
	price               *float32
	addprice            *float32
	initial_weight      *float32
	addinitial_weight   *float32
	spool_weight        *float32
	addspool_weight     *float32
	used_weight         *float32
	addused_weight      *float32
	remaining_weight    *float32
	addremaining_weight *float32
	location            *string
	lot_nr              *string
	comment             *string
	archived            *bool
	clearedFields       map[string]struct{}
	filament            *int
	clearedfilament     bool
	extra               map[int]struct{}
	removedextra        map[int]struct{}
	clearedextra        bool
	done                bool
	oldValue            func(context.Context) (*Spool, error)
	predicates          []predicate.Spool
}

var _ ent.Mutation = (*SpoolMutation)(nil)

// spoolOption allows management of the mutation configuration using functional options.
type spoolOption func(*SpoolMutation)

// newSpoolMutation creates new mutation for the Spool entity.
func newSpoolMutation(c config, op Op, opts ...spoolOption) *SpoolMutation {
	m := &SpoolMutation{
		config:        c,
		op:            op,
		typ:           TypeSpool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpoolID sets the ID field of the mutation.
func withSpoolID(id int) spoolOption {
	return func(m *SpoolMutation) {
		var (
			err   error
			once  sync.Once
			value *Spool
		)
		m.oldValue = func(ctx context.Context) (*Spool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Spool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpool sets the old Spool of the mutation.
func withSpool(node *Spool) spoolOption {
	return func(m *SpoolMutation) {
		m.oldValue = func(context.Context) (*Spool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Spool entities.
func (m *SpoolMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpoolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpoolMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Spool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRegistered sets the "registered" field.
func (m *SpoolMutation) SetRegistered(t time.Time) {
	m.registered = &t
}

// Registered returns the value of the "registered" field in the mutation.
func (m *SpoolMutation) Registered() (r time.Time, exists bool) {
	v := m.registered
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistered returns the old "registered" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldRegistered(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistered: %w", err)
	}
	return oldValue.Registered, nil
}

// ResetRegistered resets all changes to the "registered" field.
func (m *SpoolMutation) ResetRegistered() {
	m.registered = nil
}

// SetFirstUsed sets the "first_used" field.
func (m *SpoolMutation) SetFirstUsed(t time.Time) {
	m.first_used = &t
}

// FirstUsed returns the value of the "first_used" field in the mutation.
func (m *SpoolMutation) FirstUsed() (r time.Time, exists bool) {
	v := m.first_used
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstUsed returns the old "first_used" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldFirstUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstUsed: %w", err)
	}
	return oldValue.FirstUsed, nil
}

// ClearFirstUsed clears the value of the "first_used" field.
func (m *SpoolMutation) ClearFirstUsed() {
	m.first_used = nil
	m.clearedFields[spool.FieldFirstUsed] = struct{}{}
}

// FirstUsedCleared returns if the "first_used" field was cleared in this mutation.
func (m *SpoolMutation) FirstUsedCleared() bool {
	_, ok := m.clearedFields[spool.FieldFirstUsed]
	return ok
}

// ResetFirstUsed resets all changes to the "first_used" field.
func (m *SpoolMutation) ResetFirstUsed() {
	m.first_used = nil
	delete(m.clearedFields, spool.FieldFirstUsed)
}

// SetLastUsed sets the "last_used" field.
func (m *SpoolMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *SpoolMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *SpoolMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[spool.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *SpoolMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[spool.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *SpoolMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, spool.FieldLastUsed)
}

// SetPrice sets the "price" field.
func (m *SpoolMutation) SetPrice(f float32) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SpoolMutation) Price() (r float32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldPrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *SpoolMutation) AddPrice(f float32) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SpoolMutation) AddedPrice() (r float32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *SpoolMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[spool.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *SpoolMutation) PriceCleared() bool {
	_, ok := m.clearedFields[spool.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *SpoolMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, spool.FieldPrice)
}

// SetFilamentID sets the "filament_id" field.
func (m *SpoolMutation) SetFilamentID(i int) {
	m.filament = &i
}

// FilamentID returns the value of the "filament_id" field in the mutation.
func (m *SpoolMutation) FilamentID() (r int, exists bool) {
	v := m.filament
	if v == nil {
		return
	}
	return *v, true
}

// OldFilamentID returns the old "filament_id" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldFilamentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilamentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilamentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilamentID: %w", err)
	}
	return oldValue.FilamentID, nil
}

// ResetFilamentID resets all changes to the "filament_id" field.
func (m *SpoolMutation) ResetFilamentID() {
	m.filament = nil
}

// SetInitialWeight sets the "initial_weight" field.
func (m *SpoolMutation) SetInitialWeight(f float32) {
	m.initial_weight = &f
	m.addinitial_weight = nil
}

// InitialWeight returns the value of the "initial_weight" field in the mutation.
func (m *SpoolMutation) InitialWeight() (r float32, exists bool) {
	v := m.initial_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialWeight returns the old "initial_weight" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldInitialWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialWeight: %w", err)
	}
	return oldValue.InitialWeight, nil
}

// AddInitialWeight adds f to the "initial_weight" field.
func (m *SpoolMutation) AddInitialWeight(f float32) {
	if m.addinitial_weight != nil {
		*m.addinitial_weight += f
	} else {
		m.addinitial_weight = &f
	}
}

// AddedInitialWeight returns the value that was added to the "initial_weight" field in this mutation.
func (m *SpoolMutation) AddedInitialWeight() (r float32, exists bool) {
	v := m.addinitial_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearInitialWeight clears the value of the "initial_weight" field.
func (m *SpoolMutation) ClearInitialWeight() {
	m.initial_weight = nil
	m.addinitial_weight = nil
	m.clearedFields[spool.FieldInitialWeight] = struct{}{}
}

// InitialWeightCleared returns if the "initial_weight" field was cleared in this mutation.
func (m *SpoolMutation) InitialWeightCleared() bool {
	_, ok := m.clearedFields[spool.FieldInitialWeight]
	return ok
}

// ResetInitialWeight resets all changes to the "initial_weight" field.
func (m *SpoolMutation) ResetInitialWeight() {
	m.initial_weight = nil
	m.addinitial_weight = nil
	delete(m.clearedFields, spool.FieldInitialWeight)
}

// SetSpoolWeight sets the "spool_weight" field.
func (m *SpoolMutation) SetSpoolWeight(f float32) {
	m.spool_weight = &f
	m.addspool_weight = nil
}

// SpoolWeight returns the value of the "spool_weight" field in the mutation.
func (m *SpoolMutation) SpoolWeight() (r float32, exists bool) {
	v := m.spool_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldSpoolWeight returns the old "spool_weight" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldSpoolWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpoolWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpoolWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpoolWeight: %w", err)
	}
	return oldValue.SpoolWeight, nil
}

// AddSpoolWeight adds f to the "spool_weight" field.
func (m *SpoolMutation) AddSpoolWeight(f float32) {
	if m.addspool_weight != nil {
		*m.addspool_weight += f
	} else {
		m.addspool_weight = &f
	}
}

// AddedSpoolWeight returns the value that was added to the "spool_weight" field in this mutation.
func (m *SpoolMutation) AddedSpoolWeight() (r float32, exists bool) {
	v := m.addspool_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpoolWeight clears the value of the "spool_weight" field.
func (m *SpoolMutation) ClearSpoolWeight() {
	m.spool_weight = nil
	m.addspool_weight = nil
	m.clearedFields[spool.FieldSpoolWeight] = struct{}{}
}

// SpoolWeightCleared returns if the "spool_weight" field was cleared in this mutation.
func (m *SpoolMutation) SpoolWeightCleared() bool {
	_, ok := m.clearedFields[spool.FieldSpoolWeight]
	return ok
}

// ResetSpoolWeight resets all changes to the "spool_weight" field.
func (m *SpoolMutation) ResetSpoolWeight() {
	m.spool_weight = nil
	m.addspool_weight = nil
	delete(m.clearedFields, spool.FieldSpoolWeight)
}

// SetUsedWeight sets the "used_weight" field.
func (m *SpoolMutation) SetUsedWeight(f float32) {
	m.used_weight = &f
	m.addused_weight = nil
}

// UsedWeight returns the value of the "used_weight" field in the mutation.
func (m *SpoolMutation) UsedWeight() (r float32, exists bool) {
	v := m.used_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedWeight returns the old "used_weight" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldUsedWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedWeight: %w", err)
	}
	return oldValue.UsedWeight, nil
}

// AddUsedWeight adds f to the "used_weight" field.
func (m *SpoolMutation) AddUsedWeight(f float32) {
	if m.addused_weight != nil {
		*m.addused_weight += f
	} else {
		m.addused_weight = &f
	}
}

// AddedUsedWeight returns the value that was added to the "used_weight" field in this mutation.
func (m *SpoolMutation) AddedUsedWeight() (r float32, exists bool) {
	v := m.addused_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedWeight resets all changes to the "used_weight" field.
func (m *SpoolMutation) ResetUsedWeight() {
	m.used_weight = nil
	m.addused_weight = nil
}

// SetRemainingWeight sets the "remaining_weight" field.
func (m *SpoolMutation) SetRemainingWeight(f float32) {
	m.remaining_weight = &f
	m.addremaining_weight = nil
}

// RemainingWeight returns the value of the "remaining_weight" field in the mutation.
func (m *SpoolMutation) RemainingWeight() (r float32, exists bool) {
	v := m.remaining_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingWeight returns the old "remaining_weight" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldRemainingWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingWeight: %w", err)
	}
	return oldValue.RemainingWeight, nil
}

// AddRemainingWeight adds f to the "remaining_weight" field.
func (m *SpoolMutation) AddRemainingWeight(f float32) {
	if m.addremaining_weight != nil {
		*m.addremaining_weight += f
	} else {
		m.addremaining_weight = &f
	}
}

// AddedRemainingWeight returns the value that was added to the "remaining_weight" field in this mutation.
func (m *SpoolMutation) AddedRemainingWeight() (r float32, exists bool) {
	v := m.addremaining_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainingWeight resets all changes to the "remaining_weight" field.
func (m *SpoolMutation) ResetRemainingWeight() {
	m.remaining_weight = nil
	m.addremaining_weight = nil
}

// SetLocation sets the "location" field.
func (m *SpoolMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *SpoolMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *SpoolMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[spool.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *SpoolMutation) LocationCleared() bool {
	_, ok := m.clearedFields[spool.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *SpoolMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, spool.FieldLocation)
}

// SetLotNr sets the "lot_nr" field.
func (m *SpoolMutation) SetLotNr(s string) {
	m.lot_nr = &s
}

// LotNr returns the value of the "lot_nr" field in the mutation.
func (m *SpoolMutation) LotNr() (r string, exists bool) {
	v := m.lot_nr
	if v == nil {
		return
	}
	return *v, true
}

// OldLotNr returns the old "lot_nr" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldLotNr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotNr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotNr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotNr: %w", err)
	}
	return oldValue.LotNr, nil
}

// ClearLotNr clears the value of the "lot_nr" field.
func (m *SpoolMutation) ClearLotNr() {
	m.lot_nr = nil
	m.clearedFields[spool.FieldLotNr] = struct{}{}
}

// LotNrCleared returns if the "lot_nr" field was cleared in this mutation.
func (m *SpoolMutation) LotNrCleared() bool {
	_, ok := m.clearedFields[spool.FieldLotNr]
	return ok
}

// ResetLotNr resets all changes to the "lot_nr" field.
func (m *SpoolMutation) ResetLotNr() {
	m.lot_nr = nil
	delete(m.clearedFields, spool.FieldLotNr)
}

// SetComment sets the "comment" field.
func (m *SpoolMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *SpoolMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *SpoolMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[spool.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *SpoolMutation) CommentCleared() bool {
	_, ok := m.clearedFields[spool.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *SpoolMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, spool.FieldComment)
}

// SetArchived sets the "archived" field.
func (m *SpoolMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *SpoolMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the Spool entity.
// If the Spool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ClearArchived clears the value of the "archived" field.
func (m *SpoolMutation) ClearArchived() {
	m.archived = nil
	m.clearedFields[spool.FieldArchived] = struct{}{}
}

// ArchivedCleared returns if the "archived" field was cleared in this mutation.
func (m *SpoolMutation) ArchivedCleared() bool {
	_, ok := m.clearedFields[spool.FieldArchived]
	return ok
}

// ResetArchived resets all changes to the "archived" field.
func (m *SpoolMutation) ResetArchived() {
	m.archived = nil
	delete(m.clearedFields, spool.FieldArchived)
}

// ClearFilament clears the "filament" edge to the Filament entity.
func (m *SpoolMutation) ClearFilament() {
	m.clearedfilament = true
	m.clearedFields[spool.FieldFilamentID] = struct{}{}
}

// FilamentCleared reports if the "filament" edge to the Filament entity was cleared.
func (m *SpoolMutation) FilamentCleared() bool {
	return m.clearedfilament
}

// FilamentIDs returns the "filament" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FilamentID instead. It exists only for internal usage by the builders.
func (m *SpoolMutation) FilamentIDs() (ids []int) {
	if id := m.filament; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFilament resets all changes to the "filament" edge.
func (m *SpoolMutation) ResetFilament() {
	m.filament = nil
	m.clearedfilament = false
}

// AddExtraIDs adds the "extra" edge to the SpoolField entity by ids.
func (m *SpoolMutation) AddExtraIDs(ids ...int) {
	if m.extra == nil {
		m.extra = make(map[int]struct{})
	}
	for i := range ids {
		m.extra[ids[i]] = struct{}{}
	}
}

// ClearExtra clears the "extra" edge to the SpoolField entity.
func (m *SpoolMutation) ClearExtra() {
	m.clearedextra = true
}

// ExtraCleared reports if the "extra" edge to the SpoolField entity was cleared.
func (m *SpoolMutation) ExtraCleared() bool {
	return m.clearedextra
}

// RemoveExtraIDs removes the "extra" edge to the SpoolField entity by IDs.
func (m *SpoolMutation) RemoveExtraIDs(ids ...int) {
	if m.removedextra == nil {
		m.removedextra = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.extra, ids[i])
		m.removedextra[ids[i]] = struct{}{}
	}
}

// RemovedExtra returns the removed IDs of the "extra" edge to the SpoolField entity.
func (m *SpoolMutation) RemovedExtraIDs() (ids []int) {
	for id := range m.removedextra {
		ids = append(ids, id)
	}
	return
}

// ExtraIDs returns the "extra" edge IDs in the mutation.
func (m *SpoolMutation) ExtraIDs() (ids []int) {
	for id := range m.extra {
		ids = append(ids, id)
	}
	return
}

// ResetExtra resets all changes to the "extra" edge.
func (m *SpoolMutation) ResetExtra() {
	m.extra = nil
	m.clearedextra = false
	m.removedextra = nil
}

// Where appends a list predicates to the SpoolMutation builder.
func (m *SpoolMutation) Where(ps ...predicate.Spool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Spool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Spool).
func (m *SpoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpoolMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.registered != nil {
		fields = append(fields, spool.FieldRegistered)
	}
	if m.first_used != nil {
		fields = append(fields, spool.FieldFirstUsed)
	}
	if m.last_used != nil {
		fields = append(fields, spool.FieldLastUsed)
	}
	if m.price != nil {
		fields = append(fields, spool.FieldPrice)
	}
	if m.filament != nil {
		fields = append(fields, spool.FieldFilamentID)
	}
	if m.initial_weight != nil {
		fields = append(fields, spool.FieldInitialWeight)
	}
	if m.spool_weight != nil {
		fields = append(fields, spool.FieldSpoolWeight)
	}
	if m.used_weight != nil {
		fields = append(fields, spool.FieldUsedWeight)
	}
	if m.remaining_weight != nil {
		fields = append(fields, spool.FieldRemainingWeight)
	}
	if m.location != nil {
		fields = append(fields, spool.FieldLocation)
	}
	if m.lot_nr != nil {
		fields = append(fields, spool.FieldLotNr)
	}
	if m.comment != nil {
		fields = append(fields, spool.FieldComment)
	}
	if m.archived != nil {
		fields = append(fields, spool.FieldArchived)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spool.FieldRegistered:
		return m.Registered()
	case spool.FieldFirstUsed:
		return m.FirstUsed()
	case spool.FieldLastUsed:
		return m.LastUsed()
	case spool.FieldPrice:
		return m.Price()
	case spool.FieldFilamentID:
		return m.FilamentID()
	case spool.FieldInitialWeight:
		return m.InitialWeight()
	case spool.FieldSpoolWeight:
		return m.SpoolWeight()
	case spool.FieldUsedWeight:
		return m.UsedWeight()
	case spool.FieldRemainingWeight:
		return m.RemainingWeight()
	case spool.FieldLocation:
		return m.Location()
	case spool.FieldLotNr:
		return m.LotNr()
	case spool.FieldComment:
		return m.Comment()
	case spool.FieldArchived:
		return m.Archived()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spool.FieldRegistered:
		return m.OldRegistered(ctx)
	case spool.FieldFirstUsed:
		return m.OldFirstUsed(ctx)
	case spool.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case spool.FieldPrice:
		return m.OldPrice(ctx)
	case spool.FieldFilamentID:
		return m.OldFilamentID(ctx)
	case spool.FieldInitialWeight:
		return m.OldInitialWeight(ctx)
	case spool.FieldSpoolWeight:
		return m.OldSpoolWeight(ctx)
	case spool.FieldUsedWeight:
		return m.OldUsedWeight(ctx)
	case spool.FieldRemainingWeight:
		return m.OldRemainingWeight(ctx)
	case spool.FieldLocation:
		return m.OldLocation(ctx)
	case spool.FieldLotNr:
		return m.OldLotNr(ctx)
	case spool.FieldComment:
		return m.OldComment(ctx)
	case spool.FieldArchived:
		return m.OldArchived(ctx)
	}
	return nil, fmt.Errorf("unknown Spool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spool.FieldRegistered:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistered(v)
		return nil
	case spool.FieldFirstUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstUsed(v)
		return nil
	case spool.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case spool.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case spool.FieldFilamentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilamentID(v)
		return nil
	case spool.FieldInitialWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialWeight(v)
		return nil
	case spool.FieldSpoolWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpoolWeight(v)
		return nil
	case spool.FieldUsedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedWeight(v)
		return nil
	case spool.FieldRemainingWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingWeight(v)
		return nil
	case spool.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case spool.FieldLotNr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotNr(v)
		return nil
	case spool.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case spool.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	}
	return fmt.Errorf("unknown Spool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpoolMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, spool.FieldPrice)
	}
	if m.addinitial_weight != nil {
		fields = append(fields, spool.FieldInitialWeight)
	}
	if m.addspool_weight != nil {
		fields = append(fields, spool.FieldSpoolWeight)
	}
	if m.addused_weight != nil {
		fields = append(fields, spool.FieldUsedWeight)
	}
	if m.addremaining_weight != nil {
		fields = append(fields, spool.FieldRemainingWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spool.FieldPrice:
		return m.AddedPrice()
	case spool.FieldInitialWeight:
		return m.AddedInitialWeight()
	case spool.FieldSpoolWeight:
		return m.AddedSpoolWeight()
	case spool.FieldUsedWeight:
		return m.AddedUsedWeight()
	case spool.FieldRemainingWeight:
		return m.AddedRemainingWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spool.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case spool.FieldInitialWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitialWeight(v)
		return nil
	case spool.FieldSpoolWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpoolWeight(v)
		return nil
	case spool.FieldUsedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedWeight(v)
		return nil
	case spool.FieldRemainingWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Spool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpoolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spool.FieldFirstUsed) {
		fields = append(fields, spool.FieldFirstUsed)
	}
	if m.FieldCleared(spool.FieldLastUsed) {
		fields = append(fields, spool.FieldLastUsed)
	}
	if m.FieldCleared(spool.FieldPrice) {
		fields = append(fields, spool.FieldPrice)
	}
	if m.FieldCleared(spool.FieldInitialWeight) {
		fields = append(fields, spool.FieldInitialWeight)
	}
	if m.FieldCleared(spool.FieldSpoolWeight) {
		fields = append(fields, spool.FieldSpoolWeight)
	}
	if m.FieldCleared(spool.FieldLocation) {
		fields = append(fields, spool.FieldLocation)
	}
	if m.FieldCleared(spool.FieldLotNr) {
		fields = append(fields, spool.FieldLotNr)
	}
	if m.FieldCleared(spool.FieldComment) {
		fields = append(fields, spool.FieldComment)
	}
	if m.FieldCleared(spool.FieldArchived) {
		fields = append(fields, spool.FieldArchived)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpoolMutation) ClearField(name string) error {
	switch name {
	case spool.FieldFirstUsed:
		m.ClearFirstUsed()
		return nil
	case spool.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case spool.FieldPrice:
		m.ClearPrice()
		return nil
	case spool.FieldInitialWeight:
		m.ClearInitialWeight()
		return nil
	case spool.FieldSpoolWeight:
		m.ClearSpoolWeight()
		return nil
	case spool.FieldLocation:
		m.ClearLocation()
		return nil
	case spool.FieldLotNr:
		m.ClearLotNr()
		return nil
	case spool.FieldComment:
		m.ClearComment()
		return nil
	case spool.FieldArchived:
		m.ClearArchived()
		return nil
	}
	return fmt.Errorf("unknown Spool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpoolMutation) ResetField(name string) error {
	switch name {
	case spool.FieldRegistered:
		m.ResetRegistered()
		return nil
	case spool.FieldFirstUsed:
		m.ResetFirstUsed()
		return nil
	case spool.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case spool.FieldPrice:
		m.ResetPrice()
		return nil
	case spool.FieldFilamentID:
		m.ResetFilamentID()
		return nil
	case spool.FieldInitialWeight:
		m.ResetInitialWeight()
		return nil
	case spool.FieldSpoolWeight:
		m.ResetSpoolWeight()
		return nil
	case spool.FieldUsedWeight:
		m.ResetUsedWeight()
		return nil
	case spool.FieldRemainingWeight:
		m.ResetRemainingWeight()
		return nil
	case spool.FieldLocation:
		m.ResetLocation()
		return nil
	case spool.FieldLotNr:
		m.ResetLotNr()
		return nil
	case spool.FieldComment:
		m.ResetComment()
		return nil
	case spool.FieldArchived:
		m.ResetArchived()
		return nil
	}
	return fmt.Errorf("unknown Spool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.filament != nil {
		edges = append(edges, spool.EdgeFilament)
	}
	if m.extra != nil {
		edges = append(edges, spool.EdgeExtra)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spool.EdgeFilament:
		if id := m.filament; id != nil {
			return []ent.Value{*id}
		}
	case spool.EdgeExtra:
		ids := make([]ent.Value, 0, len(m.extra))
		for id := range m.extra {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedextra != nil {
		edges = append(edges, spool.EdgeExtra)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case spool.EdgeExtra:
		ids := make([]ent.Value, 0, len(m.removedextra))
		for id := range m.removedextra {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfilament {
		edges = append(edges, spool.EdgeFilament)
	}
	if m.clearedextra {
		edges = append(edges, spool.EdgeExtra)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpoolMutation) EdgeCleared(name string) bool {
	switch name {
	case spool.EdgeFilament:
		return m.clearedfilament
	case spool.EdgeExtra:
		return m.clearedextra
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpoolMutation) ClearEdge(name string) error {
	switch name {
	case spool.EdgeFilament:
		m.ClearFilament()
		return nil
	}
	return fmt.Errorf("unknown Spool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpoolMutation) ResetEdge(name string) error {
	switch name {
	case spool.EdgeFilament:
		m.ResetFilament()
		return nil
	case spool.EdgeExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown Spool edge %s", name)
}

// SpoolFieldMutation represents an operation that mutates the SpoolField nodes in the graph.
type SpoolFieldMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	spool         *int
	clearedspool  bool
	done          bool
	oldValue      func(context.Context) (*SpoolField, error)
	predicates    []predicate.SpoolField
}

var _ ent.Mutation = (*SpoolFieldMutation)(nil)

// spoolfieldOption allows management of the mutation configuration using functional options.
type spoolfieldOption func(*SpoolFieldMutation)

// newSpoolFieldMutation creates new mutation for the SpoolField entity.
func newSpoolFieldMutation(c config, op Op, opts ...spoolfieldOption) *SpoolFieldMutation {
	m := &SpoolFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeSpoolField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpoolFieldID sets the ID field of the mutation.
func withSpoolFieldID(id int) spoolfieldOption {
	return func(m *SpoolFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *SpoolField
		)
		m.oldValue = func(ctx context.Context) (*SpoolField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpoolField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpoolField sets the old SpoolField of the mutation.
func withSpoolField(node *SpoolField) spoolfieldOption {
	return func(m *SpoolFieldMutation) {
		m.oldValue = func(context.Context) (*SpoolField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpoolFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpoolFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpoolFieldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpoolFieldMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SpoolField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpoolID sets the "spool_id" field.
func (m *SpoolFieldMutation) SetSpoolID(i int) {
	m.spool = &i
}

// SpoolID returns the value of the "spool_id" field in the mutation.
func (m *SpoolFieldMutation) SpoolID() (r int, exists bool) {
	v := m.spool
	if v == nil {
		return
	}
	return *v, true
}

// OldSpoolID returns the old "spool_id" field's value of the SpoolField entity.
// If the SpoolField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolFieldMutation) OldSpoolID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpoolID: %w", err)
	}
	return oldValue.SpoolID, nil
}

// ResetSpoolID resets all changes to the "spool_id" field.
func (m *SpoolFieldMutation) ResetSpoolID() {
	m.spool = nil
}

// SetKey sets the "key" field.
func (m *SpoolFieldMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SpoolFieldMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SpoolField entity.
// If the SpoolField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolFieldMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SpoolFieldMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SpoolFieldMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SpoolFieldMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SpoolField entity.
// If the SpoolField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolFieldMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SpoolFieldMutation) ResetValue() {
	m.value = nil
}

// ClearSpool clears the "spool" edge to the Spool entity.
func (m *SpoolFieldMutation) ClearSpool() {
	m.clearedspool = true
	m.clearedFields[spoolfield.FieldSpoolID] = struct{}{}
}

// SpoolCleared reports if the "spool" edge to the Spool entity was cleared.
func (m *SpoolFieldMutation) SpoolCleared() bool {
	return m.clearedspool
}

// SpoolIDs returns the "spool" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpoolID instead. It exists only for internal usage by the builders.
func (m *SpoolFieldMutation) SpoolIDs() (ids []int) {
	if id := m.spool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpool resets all changes to the "spool" edge.
func (m *SpoolFieldMutation) ResetSpool() {
	m.spool = nil
	m.clearedspool = false
}

// Where appends a list predicates to the SpoolFieldMutation builder.
func (m *SpoolFieldMutation) Where(ps ...predicate.SpoolField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpoolFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpoolFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SpoolField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpoolFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpoolFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SpoolField).
func (m *SpoolFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpoolFieldMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.spool != nil {
		fields = append(fields, spoolfield.FieldSpoolID)
	}
	if m.key != nil {
		fields = append(fields, spoolfield.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, spoolfield.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpoolFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spoolfield.FieldSpoolID:
		return m.SpoolID()
	case spoolfield.FieldKey:
		return m.Key()
	case spoolfield.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpoolFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spoolfield.FieldSpoolID:
		return m.OldSpoolID(ctx)
	case spoolfield.FieldKey:
		return m.OldKey(ctx)
	case spoolfield.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown SpoolField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpoolFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spoolfield.FieldSpoolID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpoolID(v)
		return nil
	case spoolfield.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case spoolfield.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown SpoolField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpoolFieldMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpoolFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpoolFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SpoolField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpoolFieldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpoolFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpoolFieldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SpoolField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpoolFieldMutation) ResetField(name string) error {
	switch name {
	case spoolfield.FieldSpoolID:
		m.ResetSpoolID()
		return nil
	case spoolfield.FieldKey:
		m.ResetKey()
		return nil
	case spoolfield.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown SpoolField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpoolFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spool != nil {
		edges = append(edges, spoolfield.EdgeSpool)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpoolFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spoolfield.EdgeSpool:
		if id := m.spool; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpoolFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpoolFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpoolFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspool {
		edges = append(edges, spoolfield.EdgeSpool)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpoolFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case spoolfield.EdgeSpool:
		return m.clearedspool
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpoolFieldMutation) ClearEdge(name string) error {
	switch name {
	case spoolfield.EdgeSpool:
		m.ClearSpool()
		return nil
	}
	return fmt.Errorf("unknown SpoolField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpoolFieldMutation) ResetEdge(name string) error {
	switch name {
	case spoolfield.EdgeSpool:
		m.ResetSpool()
		return nil
	}
	return fmt.Errorf("unknown SpoolField edge %s", name)
}

// SpoolVendorMutation represents an operation that mutates the SpoolVendor nodes in the graph.
type SpoolVendorMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	registered            *time.Time
	name                  *string
	empty_spool_weight    *float32
	addempty_spool_weight *float32
	comment               *string
	external_id           *string
	clearedFields         map[string]struct{}
	filaments             map[int]struct{}
	removedfilaments      map[int]struct{}
	clearedfilaments      bool
	extra                 map[int]struct{}
	removedextra          map[int]struct{}
	clearedextra          bool
	done                  bool
	oldValue              func(context.Context) (*SpoolVendor, error)
	predicates            []predicate.SpoolVendor
}

var _ ent.Mutation = (*SpoolVendorMutation)(nil)

// spoolvendorOption allows management of the mutation configuration using functional options.
type spoolvendorOption func(*SpoolVendorMutation)

// newSpoolVendorMutation creates new mutation for the SpoolVendor entity.
func newSpoolVendorMutation(c config, op Op, opts ...spoolvendorOption) *SpoolVendorMutation {
	m := &SpoolVendorMutation{
		config:        c,
		op:            op,
		typ:           TypeSpoolVendor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpoolVendorID sets the ID field of the mutation.
func withSpoolVendorID(id int) spoolvendorOption {
	return func(m *SpoolVendorMutation) {
		var (
			err   error
			once  sync.Once
			value *SpoolVendor
		)
		m.oldValue = func(ctx context.Context) (*SpoolVendor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpoolVendor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpoolVendor sets the old SpoolVendor of the mutation.
func withSpoolVendor(node *SpoolVendor) spoolvendorOption {
	return func(m *SpoolVendorMutation) {
		m.oldValue = func(context.Context) (*SpoolVendor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpoolVendorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpoolVendorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SpoolVendor entities.
func (m *SpoolVendorMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpoolVendorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpoolVendorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SpoolVendor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRegistered sets the "registered" field.
func (m *SpoolVendorMutation) SetRegistered(t time.Time) {
	m.registered = &t
}

// Registered returns the value of the "registered" field in the mutation.
func (m *SpoolVendorMutation) Registered() (r time.Time, exists bool) {
	v := m.registered
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistered returns the old "registered" field's value of the SpoolVendor entity.
// If the SpoolVendor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolVendorMutation) OldRegistered(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistered: %w", err)
	}
	return oldValue.Registered, nil
}

// ResetRegistered resets all changes to the "registered" field.
func (m *SpoolVendorMutation) ResetRegistered() {
	m.registered = nil
}

// SetName sets the "name" field.
func (m *SpoolVendorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpoolVendorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SpoolVendor entity.
// If the SpoolVendor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolVendorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpoolVendorMutation) ResetName() {
	m.name = nil
}

// SetEmptySpoolWeight sets the "empty_spool_weight" field.
func (m *SpoolVendorMutation) SetEmptySpoolWeight(f float32) {
	m.empty_spool_weight = &f
	m.addempty_spool_weight = nil
}

// EmptySpoolWeight returns the value of the "empty_spool_weight" field in the mutation.
func (m *SpoolVendorMutation) EmptySpoolWeight() (r float32, exists bool) {
	v := m.empty_spool_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldEmptySpoolWeight returns the old "empty_spool_weight" field's value of the SpoolVendor entity.
// If the SpoolVendor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolVendorMutation) OldEmptySpoolWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmptySpoolWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmptySpoolWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmptySpoolWeight: %w", err)
	}
	return oldValue.EmptySpoolWeight, nil
}

// AddEmptySpoolWeight adds f to the "empty_spool_weight" field.
func (m *SpoolVendorMutation) AddEmptySpoolWeight(f float32) {
	if m.addempty_spool_weight != nil {
		*m.addempty_spool_weight += f
	} else {
		m.addempty_spool_weight = &f
	}
}

// AddedEmptySpoolWeight returns the value that was added to the "empty_spool_weight" field in this mutation.
func (m *SpoolVendorMutation) AddedEmptySpoolWeight() (r float32, exists bool) {
	v := m.addempty_spool_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmptySpoolWeight clears the value of the "empty_spool_weight" field.
func (m *SpoolVendorMutation) ClearEmptySpoolWeight() {
	m.empty_spool_weight = nil
	m.addempty_spool_weight = nil
	m.clearedFields[spoolvendor.FieldEmptySpoolWeight] = struct{}{}
}

// EmptySpoolWeightCleared returns if the "empty_spool_weight" field was cleared in this mutation.
func (m *SpoolVendorMutation) EmptySpoolWeightCleared() bool {
	_, ok := m.clearedFields[spoolvendor.FieldEmptySpoolWeight]
	return ok
}

// ResetEmptySpoolWeight resets all changes to the "empty_spool_weight" field.
func (m *SpoolVendorMutation) ResetEmptySpoolWeight() {
	m.empty_spool_weight = nil
	m.addempty_spool_weight = nil
	delete(m.clearedFields, spoolvendor.FieldEmptySpoolWeight)
}

// SetComment sets the "comment" field.
func (m *SpoolVendorMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *SpoolVendorMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the SpoolVendor entity.
// If the SpoolVendor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolVendorMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *SpoolVendorMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[spoolvendor.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *SpoolVendorMutation) CommentCleared() bool {
	_, ok := m.clearedFields[spoolvendor.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *SpoolVendorMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, spoolvendor.FieldComment)
}

// SetExternalID sets the "external_id" field.
func (m *SpoolVendorMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SpoolVendorMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the SpoolVendor entity.
// If the SpoolVendor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpoolVendorMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *SpoolVendorMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[spoolvendor.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *SpoolVendorMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[spoolvendor.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SpoolVendorMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, spoolvendor.FieldExternalID)
}

// AddFilamentIDs adds the "filaments" edge to the Filament entity by ids.
func (m *SpoolVendorMutation) AddFilamentIDs(ids ...int) {
	if m.filaments == nil {
		m.filaments = make(map[int]struct{})
	}
	for i := range ids {
		m.filaments[ids[i]] = struct{}{}
	}
}

// ClearFilaments clears the "filaments" edge to the Filament entity.
func (m *SpoolVendorMutation) ClearFilaments() {
	m.clearedfilaments = true
}

// FilamentsCleared reports if the "filaments" edge to the Filament entity was cleared.
func (m *SpoolVendorMutation) FilamentsCleared() bool {
	return m.clearedfilaments
}

// RemoveFilamentIDs removes the "filaments" edge to the Filament entity by IDs.
func (m *SpoolVendorMutation) RemoveFilamentIDs(ids ...int) {
	if m.removedfilaments == nil {
		m.removedfilaments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filaments, ids[i])
		m.removedfilaments[ids[i]] = struct{}{}
	}
}

// RemovedFilaments returns the removed IDs of the "filaments" edge to the Filament entity.
func (m *SpoolVendorMutation) RemovedFilamentsIDs() (ids []int) {
	for id := range m.removedfilaments {
		ids = append(ids, id)
	}
	return
}

// FilamentsIDs returns the "filaments" edge IDs in the mutation.
func (m *SpoolVendorMutation) FilamentsIDs() (ids []int) {
	for id := range m.filaments {
		ids = append(ids, id)
	}
	return
}

// ResetFilaments resets all changes to the "filaments" edge.
func (m *SpoolVendorMutation) ResetFilaments() {
	m.filaments = nil
	m.clearedfilaments = false
	m.removedfilaments = nil
}

// AddExtraIDs adds the "extra" edge to the VendorField entity by ids.
func (m *SpoolVendorMutation) AddExtraIDs(ids ...int) {
	if m.extra == nil {
		m.extra = make(map[int]struct{})
	}
	for i := range ids {
		m.extra[ids[i]] = struct{}{}
	}
}

// ClearExtra clears the "extra" edge to the VendorField entity.
func (m *SpoolVendorMutation) ClearExtra() {
	m.clearedextra = true
}

// ExtraCleared reports if the "extra" edge to the VendorField entity was cleared.
func (m *SpoolVendorMutation) ExtraCleared() bool {
	return m.clearedextra
}

// RemoveExtraIDs removes the "extra" edge to the VendorField entity by IDs.
func (m *SpoolVendorMutation) RemoveExtraIDs(ids ...int) {
	if m.removedextra == nil {
		m.removedextra = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.extra, ids[i])
		m.removedextra[ids[i]] = struct{}{}
	}
}

// RemovedExtra returns the removed IDs of the "extra" edge to the VendorField entity.
func (m *SpoolVendorMutation) RemovedExtraIDs() (ids []int) {
	for id := range m.removedextra {
		ids = append(ids, id)
	}
	return
}

// ExtraIDs returns the "extra" edge IDs in the mutation.
func (m *SpoolVendorMutation) ExtraIDs() (ids []int) {
	for id := range m.extra {
		ids = append(ids, id)
	}
	return
}

// ResetExtra resets all changes to the "extra" edge.
func (m *SpoolVendorMutation) ResetExtra() {
	m.extra = nil
	m.clearedextra = false
	m.removedextra = nil
}

// Where appends a list predicates to the SpoolVendorMutation builder.
func (m *SpoolVendorMutation) Where(ps ...predicate.SpoolVendor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpoolVendorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpoolVendorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SpoolVendor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpoolVendorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpoolVendorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SpoolVendor).
func (m *SpoolVendorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpoolVendorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.registered != nil {
		fields = append(fields, spoolvendor.FieldRegistered)
	}
	if m.name != nil {
		fields = append(fields, spoolvendor.FieldName)
	}
	if m.empty_spool_weight != nil {
		fields = append(fields, spoolvendor.FieldEmptySpoolWeight)
	}
	if m.comment != nil {
		fields = append(fields, spoolvendor.FieldComment)
	}
	if m.external_id != nil {
		fields = append(fields, spoolvendor.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpoolVendorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spoolvendor.FieldRegistered:
		return m.Registered()
	case spoolvendor.FieldName:
		return m.Name()
	case spoolvendor.FieldEmptySpoolWeight:
		return m.EmptySpoolWeight()
	case spoolvendor.FieldComment:
		return m.Comment()
	case spoolvendor.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpoolVendorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spoolvendor.FieldRegistered:
		return m.OldRegistered(ctx)
	case spoolvendor.FieldName:
		return m.OldName(ctx)
	case spoolvendor.FieldEmptySpoolWeight:
		return m.OldEmptySpoolWeight(ctx)
	case spoolvendor.FieldComment:
		return m.OldComment(ctx)
	case spoolvendor.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown SpoolVendor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpoolVendorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spoolvendor.FieldRegistered:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistered(v)
		return nil
	case spoolvendor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case spoolvendor.FieldEmptySpoolWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmptySpoolWeight(v)
		return nil
	case spoolvendor.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case spoolvendor.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown SpoolVendor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpoolVendorMutation) AddedFields() []string {
	var fields []string
	if m.addempty_spool_weight != nil {
		fields = append(fields, spoolvendor.FieldEmptySpoolWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpoolVendorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spoolvendor.FieldEmptySpoolWeight:
		return m.AddedEmptySpoolWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpoolVendorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spoolvendor.FieldEmptySpoolWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmptySpoolWeight(v)
		return nil
	}
	return fmt.Errorf("unknown SpoolVendor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpoolVendorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spoolvendor.FieldEmptySpoolWeight) {
		fields = append(fields, spoolvendor.FieldEmptySpoolWeight)
	}
	if m.FieldCleared(spoolvendor.FieldComment) {
		fields = append(fields, spoolvendor.FieldComment)
	}
	if m.FieldCleared(spoolvendor.FieldExternalID) {
		fields = append(fields, spoolvendor.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpoolVendorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpoolVendorMutation) ClearField(name string) error {
	switch name {
	case spoolvendor.FieldEmptySpoolWeight:
		m.ClearEmptySpoolWeight()
		return nil
	case spoolvendor.FieldComment:
		m.ClearComment()
		return nil
	case spoolvendor.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown SpoolVendor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpoolVendorMutation) ResetField(name string) error {
	switch name {
	case spoolvendor.FieldRegistered:
		m.ResetRegistered()
		return nil
	case spoolvendor.FieldName:
		m.ResetName()
		return nil
	case spoolvendor.FieldEmptySpoolWeight:
		m.ResetEmptySpoolWeight()
		return nil
	case spoolvendor.FieldComment:
		m.ResetComment()
		return nil
	case spoolvendor.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown SpoolVendor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpoolVendorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.filaments != nil {
		edges = append(edges, spoolvendor.EdgeFilaments)
	}
	if m.extra != nil {
		edges = append(edges, spoolvendor.EdgeExtra)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpoolVendorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spoolvendor.EdgeFilaments:
		ids := make([]ent.Value, 0, len(m.filaments))
		for id := range m.filaments {
			ids = append(ids, id)
		}
		return ids
	case spoolvendor.EdgeExtra:
		ids := make([]ent.Value, 0, len(m.extra))
		for id := range m.extra {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpoolVendorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfilaments != nil {
		edges = append(edges, spoolvendor.EdgeFilaments)
	}
	if m.removedextra != nil {
		edges = append(edges, spoolvendor.EdgeExtra)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpoolVendorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case spoolvendor.EdgeFilaments:
		ids := make([]ent.Value, 0, len(m.removedfilaments))
		for id := range m.removedfilaments {
			ids = append(ids, id)
		}
		return ids
	case spoolvendor.EdgeExtra:
		ids := make([]ent.Value, 0, len(m.removedextra))
		for id := range m.removedextra {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpoolVendorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfilaments {
		edges = append(edges, spoolvendor.EdgeFilaments)
	}
	if m.clearedextra {
		edges = append(edges, spoolvendor.EdgeExtra)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpoolVendorMutation) EdgeCleared(name string) bool {
	switch name {
	case spoolvendor.EdgeFilaments:
		return m.clearedfilaments
	case spoolvendor.EdgeExtra:
		return m.clearedextra
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpoolVendorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SpoolVendor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpoolVendorMutation) ResetEdge(name string) error {
	switch name {
	case spoolvendor.EdgeFilaments:
		m.ResetFilaments()
		return nil
	case spoolvendor.EdgeExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown SpoolVendor edge %s", name)
}

// VendorFieldMutation represents an operation that mutates the VendorField nodes in the graph.
type VendorFieldMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	vendor        *int
	clearedvendor bool
	done          bool
	oldValue      func(context.Context) (*VendorField, error)
	predicates    []predicate.VendorField
}

var _ ent.Mutation = (*VendorFieldMutation)(nil)

// vendorfieldOption allows management of the mutation configuration using functional options.
type vendorfieldOption func(*VendorFieldMutation)

// newVendorFieldMutation creates new mutation for the VendorField entity.
func newVendorFieldMutation(c config, op Op, opts ...vendorfieldOption) *VendorFieldMutation {
	m := &VendorFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeVendorField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorFieldID sets the ID field of the mutation.
func withVendorFieldID(id int) vendorfieldOption {
	return func(m *VendorFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *VendorField
		)
		m.oldValue = func(ctx context.Context) (*VendorField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VendorField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendorField sets the old VendorField of the mutation.
func withVendorField(node *VendorField) vendorfieldOption {
	return func(m *VendorFieldMutation) {
		m.oldValue = func(context.Context) (*VendorField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VendorFieldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VendorFieldMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VendorField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVendorID sets the "vendor_id" field.
func (m *VendorFieldMutation) SetVendorID(i int) {
	m.vendor = &i
}

// VendorID returns the value of the "vendor_id" field in the mutation.
func (m *VendorFieldMutation) VendorID() (r int, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorID returns the old "vendor_id" field's value of the VendorField entity.
// If the VendorField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorFieldMutation) OldVendorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorID: %w", err)
	}
	return oldValue.VendorID, nil
}

// ResetVendorID resets all changes to the "vendor_id" field.
func (m *VendorFieldMutation) ResetVendorID() {
	m.vendor = nil
}

// SetKey sets the "key" field.
func (m *VendorFieldMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *VendorFieldMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the VendorField entity.
// If the VendorField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorFieldMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *VendorFieldMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *VendorFieldMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *VendorFieldMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the VendorField entity.
// If the VendorField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorFieldMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *VendorFieldMutation) ResetValue() {
	m.value = nil
}

// ClearVendor clears the "vendor" edge to the SpoolVendor entity.
func (m *VendorFieldMutation) ClearVendor() {
	m.clearedvendor = true
	m.clearedFields[vendorfield.FieldVendorID] = struct{}{}
}

// VendorCleared reports if the "vendor" edge to the SpoolVendor entity was cleared.
func (m *VendorFieldMutation) VendorCleared() bool {
	return m.clearedvendor
}

// VendorIDs returns the "vendor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VendorID instead. It exists only for internal usage by the builders.
func (m *VendorFieldMutation) VendorIDs() (ids []int) {
	if id := m.vendor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendor resets all changes to the "vendor" edge.
func (m *VendorFieldMutation) ResetVendor() {
	m.vendor = nil
	m.clearedvendor = false
}

// Where appends a list predicates to the VendorFieldMutation builder.
func (m *VendorFieldMutation) Where(ps ...predicate.VendorField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VendorFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VendorFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VendorField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VendorFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VendorFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VendorField).
func (m *VendorFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VendorFieldMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.vendor != nil {
		fields = append(fields, vendorfield.FieldVendorID)
	}
	if m.key != nil {
		fields = append(fields, vendorfield.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, vendorfield.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VendorFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendorfield.FieldVendorID:
		return m.VendorID()
	case vendorfield.FieldKey:
		return m.Key()
	case vendorfield.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VendorFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendorfield.FieldVendorID:
		return m.OldVendorID(ctx)
	case vendorfield.FieldKey:
		return m.OldKey(ctx)
	case vendorfield.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown VendorField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendorfield.FieldVendorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorID(v)
		return nil
	case vendorfield.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case vendorfield.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown VendorField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VendorFieldMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VendorFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VendorField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VendorFieldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VendorFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorFieldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VendorField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VendorFieldMutation) ResetField(name string) error {
	switch name {
	case vendorfield.FieldVendorID:
		m.ResetVendorID()
		return nil
	case vendorfield.FieldKey:
		m.ResetKey()
		return nil
	case vendorfield.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown VendorField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VendorFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vendor != nil {
		edges = append(edges, vendorfield.EdgeVendor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VendorFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vendorfield.EdgeVendor:
		if id := m.vendor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VendorFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VendorFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VendorFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvendor {
		edges = append(edges, vendorfield.EdgeVendor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VendorFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case vendorfield.EdgeVendor:
		return m.clearedvendor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VendorFieldMutation) ClearEdge(name string) error {
	switch name {
	case vendorfield.EdgeVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown VendorField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VendorFieldMutation) ResetEdge(name string) error {
	switch name {
	case vendorfield.EdgeVendor:
		m.ResetVendor()
		return nil
	}
	return fmt.Errorf("unknown VendorField edge %s", name)
}
